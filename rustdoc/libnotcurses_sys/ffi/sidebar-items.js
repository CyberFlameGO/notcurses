initSidebarItems({"constant":[["AF_ALG",""],["AF_APPLETALK",""],["AF_ASH",""],["AF_ATMPVC",""],["AF_ATMSVC",""],["AF_AX25",""],["AF_BLUETOOTH",""],["AF_BRIDGE",""],["AF_CAIF",""],["AF_CAN",""],["AF_DECnet",""],["AF_ECONET",""],["AF_FILE",""],["AF_IB",""],["AF_IEEE802154",""],["AF_INET",""],["AF_INET6",""],["AF_IPX",""],["AF_IRDA",""],["AF_ISDN",""],["AF_IUCV",""],["AF_KCM",""],["AF_KEY",""],["AF_LLC",""],["AF_LOCAL",""],["AF_MAX",""],["AF_MPLS",""],["AF_NETBEUI",""],["AF_NETLINK",""],["AF_NETROM",""],["AF_NFC",""],["AF_PACKET",""],["AF_PHONET",""],["AF_PPPOX",""],["AF_QIPCRTR",""],["AF_RDS",""],["AF_ROSE",""],["AF_ROUTE",""],["AF_RXRPC",""],["AF_SECURITY",""],["AF_SMC",""],["AF_SNA",""],["AF_TIPC",""],["AF_UNIX",""],["AF_UNSPEC",""],["AF_VSOCK",""],["AF_WANPIPE",""],["AF_X25",""],["AF_XDP",""],["AIO_PRIO_DELTA_MAX",""],["ARG_MAX",""],["BC_BASE_MAX",""],["BC_DIM_MAX",""],["BC_SCALE_MAX",""],["BC_STRING_MAX",""],["BPREFIXCOLUMNS",""],["BPREFIXSTRLEN",""],["BUFSIZ",""],["CELL_ALPHA_BLEND",""],["CELL_ALPHA_HIGHCONTRAST",""],["CELL_ALPHA_OPAQUE",""],["CELL_ALPHA_TRANSPARENT",""],["CELL_BGDEFAULT_MASK",""],["CELL_BG_ALPHA_MASK",""],["CELL_BG_PALETTE",""],["CELL_BG_RGB_MASK",""],["CELL_FGDEFAULT_MASK",""],["CELL_FG_ALPHA_MASK",""],["CELL_FG_PALETTE",""],["CELL_FG_RGB_MASK",""],["CELL_NOBACKGROUND_MASK",""],["CELL_WIDEASIAN_MASK",""],["CHANNEL_ALPHA_MASK",""],["CHARCLASS_NAME_MAX",""],["COLL_WEIGHTS_MAX",""],["DELAYTIMER_MAX",""],["EOF",""],["EXIT_FAILURE",""],["EXIT_SUCCESS",""],["EXPR_NEST_MAX",""],["FILENAME_MAX",""],["FOPEN_MAX",""],["HOST_NAME_MAX",""],["INET6_ADDRSTRLEN",""],["INET_ADDRSTRLEN",""],["INT16_MAX",""],["INT16_MIN",""],["INT32_MAX",""],["INT32_MIN",""],["INT8_MAX",""],["INT8_MIN",""],["INTPTR_MAX",""],["INTPTR_MIN",""],["INT_FAST16_MAX",""],["INT_FAST16_MIN",""],["INT_FAST32_MAX",""],["INT_FAST32_MIN",""],["INT_FAST8_MAX",""],["INT_FAST8_MIN",""],["INT_LEAST16_MAX",""],["INT_LEAST16_MIN",""],["INT_LEAST32_MAX",""],["INT_LEAST32_MIN",""],["INT_LEAST8_MAX",""],["INT_LEAST8_MIN",""],["IN_CLASSA_HOST",""],["IN_CLASSA_MAX",""],["IN_CLASSA_NET",""],["IN_CLASSA_NSHIFT",""],["IN_CLASSB_HOST",""],["IN_CLASSB_MAX",""],["IN_CLASSB_NET",""],["IN_CLASSB_NSHIFT",""],["IN_CLASSC_HOST",""],["IN_CLASSC_NET",""],["IN_CLASSC_NSHIFT",""],["IN_LOOPBACKNET",""],["IOV_MAX",""],["IPPORT_BIFFUDP","UDP ports."],["IPPORT_CMDSERVER",""],["IPPORT_DAYTIME","Time of day service."],["IPPORT_DISCARD","Discard transmissions service."],["IPPORT_ECHO","Echo service."],["IPPORT_EFSSERVER",""],["IPPORT_EXECSERVER","execd service."],["IPPORT_FINGER","Finger service."],["IPPORT_FTP","File Transfer Protocol."],["IPPORT_LOGINSERVER","rlogind service."],["IPPORT_MTP",""],["IPPORT_NAMESERVER","Domain Name Service."],["IPPORT_NETSTAT","Network status service."],["IPPORT_RESERVED","Ports less than this value are reserved for privileged processes."],["IPPORT_RJE",""],["IPPORT_ROUTESERVER","UDP ports."],["IPPORT_SMTP","Simple Mail Transfer Protocol."],["IPPORT_SUPDUP","SUPDUP protocol."],["IPPORT_SYSTAT","System status service."],["IPPORT_TELNET","Telnet protocol."],["IPPORT_TFTP","Trivial File Transfer Protocol."],["IPPORT_TIMESERVER","Timeserver service."],["IPPORT_TTYLINK",""],["IPPORT_USERRESERVED","Ports greater this value are reserved for (non-privileged) servers."],["IPPORT_WHOIS","Internet Whois service."],["IPPORT_WHOSERVER","UDP ports."],["IPPROTO_AH","authentication header."],["IPPROTO_BEETPH","IP option pseudo header for BEET."],["IPPROTO_COMP","Compression Header Protocol."],["IPPROTO_DCCP","Datagram Congestion Control Protocol."],["IPPROTO_DSTOPTS","IPv6 destination options."],["IPPROTO_EGP","Exterior Gateway Protocol."],["IPPROTO_ENCAP","Encapsulation Header."],["IPPROTO_ESP","encapsulating security payload."],["IPPROTO_FRAGMENT","IPv6 fragmentation header."],["IPPROTO_GRE","General Routing Encapsulation."],["IPPROTO_HOPOPTS","IPv6 Hop-by-Hop options."],["IPPROTO_ICMP","Internet Control Message Protocol."],["IPPROTO_ICMPV6","ICMPv6."],["IPPROTO_IDP","XNS IDP protocol."],["IPPROTO_IGMP","Internet Group Management Protocol."],["IPPROTO_IP","Dummy protocol for TCP."],["IPPROTO_IPIP","IPIP tunnels (older KA9Q tunnels use 94)."],["IPPROTO_IPV6","IPv6 header."],["IPPROTO_MAX",""],["IPPROTO_MH","IPv6 mobility header."],["IPPROTO_MPLS","MPLS in IP."],["IPPROTO_MTP","Multicast Transport Protocol."],["IPPROTO_NONE","IPv6 no next header."],["IPPROTO_PIM","Protocol Independent Multicast."],["IPPROTO_PUP","PUP protocol."],["IPPROTO_RAW","Raw IP packets."],["IPPROTO_ROUTING","IPv6 routing header."],["IPPROTO_RSVP","Reservation Protocol."],["IPPROTO_SCTP","Stream Control Transmission Protocol."],["IPPROTO_TCP","Transmission Control Protocol."],["IPPROTO_TP","SO Transport Protocol Class 4."],["IPPROTO_UDP","User Datagram Protocol."],["IPPROTO_UDPLITE","UDP-Lite protocol."],["IPREFIXCOLUMNS",""],["IPREFIXSTRLEN",""],["IPV6_2292DSTOPTS",""],["IPV6_2292HOPLIMIT",""],["IPV6_2292HOPOPTS",""],["IPV6_2292PKTINFO",""],["IPV6_2292PKTOPTIONS",""],["IPV6_2292RTHDR",""],["IPV6_ADDRFORM",""],["IPV6_ADDR_PREFERENCES",""],["IPV6_ADD_MEMBERSHIP",""],["IPV6_AUTHHDR",""],["IPV6_AUTOFLOWLABEL",""],["IPV6_CHECKSUM",""],["IPV6_DONTFRAG",""],["IPV6_DROP_MEMBERSHIP",""],["IPV6_DSTOPTS",""],["IPV6_FREEBIND",""],["IPV6_HDRINCL",""],["IPV6_HOPLIMIT",""],["IPV6_HOPOPTS",""],["IPV6_IPSEC_POLICY",""],["IPV6_JOIN_ANYCAST",""],["IPV6_JOIN_GROUP",""],["IPV6_LEAVE_ANYCAST",""],["IPV6_LEAVE_GROUP",""],["IPV6_MINHOPCOUNT",""],["IPV6_MTU",""],["IPV6_MTU_DISCOVER",""],["IPV6_MULTICAST_ALL",""],["IPV6_MULTICAST_HOPS",""],["IPV6_MULTICAST_IF",""],["IPV6_MULTICAST_LOOP",""],["IPV6_NEXTHOP",""],["IPV6_ORIGDSTADDR",""],["IPV6_PATHMTU",""],["IPV6_PKTINFO",""],["IPV6_PMTUDISC_DO",""],["IPV6_PMTUDISC_DONT",""],["IPV6_PMTUDISC_INTERFACE",""],["IPV6_PMTUDISC_OMIT",""],["IPV6_PMTUDISC_PROBE",""],["IPV6_PMTUDISC_WANT",""],["IPV6_RECVDSTOPTS",""],["IPV6_RECVERR",""],["IPV6_RECVFRAGSIZE",""],["IPV6_RECVHOPLIMIT",""],["IPV6_RECVHOPOPTS",""],["IPV6_RECVORIGDSTADDR",""],["IPV6_RECVPATHMTU",""],["IPV6_RECVPKTINFO",""],["IPV6_RECVRTHDR",""],["IPV6_RECVTCLASS",""],["IPV6_ROUTER_ALERT",""],["IPV6_ROUTER_ALERT_ISOLATE",""],["IPV6_RTHDR",""],["IPV6_RTHDRDSTOPTS",""],["IPV6_RTHDR_LOOSE",""],["IPV6_RTHDR_STRICT",""],["IPV6_RTHDR_TYPE_0",""],["IPV6_RXDSTOPTS",""],["IPV6_RXHOPOPTS",""],["IPV6_TCLASS",""],["IPV6_TRANSPARENT",""],["IPV6_UNICAST_HOPS",""],["IPV6_UNICAST_IF",""],["IPV6_V6ONLY",""],["IPV6_XFRM_POLICY",""],["IP_ADD_MEMBERSHIP",""],["IP_ADD_SOURCE_MEMBERSHIP",""],["IP_BIND_ADDRESS_NO_PORT",""],["IP_BLOCK_SOURCE",""],["IP_CHECKSUM",""],["IP_DEFAULT_MULTICAST_LOOP",""],["IP_DEFAULT_MULTICAST_TTL",""],["IP_DROP_MEMBERSHIP",""],["IP_DROP_SOURCE_MEMBERSHIP",""],["IP_FREEBIND",""],["IP_HDRINCL",""],["IP_IPSEC_POLICY",""],["IP_MAX_MEMBERSHIPS",""],["IP_MINTTL",""],["IP_MSFILTER",""],["IP_MTU",""],["IP_MTU_DISCOVER",""],["IP_MULTICAST_ALL",""],["IP_MULTICAST_IF",""],["IP_MULTICAST_LOOP",""],["IP_MULTICAST_TTL",""],["IP_NODEFRAG",""],["IP_OPTIONS",""],["IP_ORIGDSTADDR",""],["IP_PASSSEC",""],["IP_PKTINFO",""],["IP_PKTOPTIONS",""],["IP_PMTUDISC",""],["IP_PMTUDISC_DO",""],["IP_PMTUDISC_DONT",""],["IP_PMTUDISC_INTERFACE",""],["IP_PMTUDISC_OMIT",""],["IP_PMTUDISC_PROBE",""],["IP_PMTUDISC_WANT",""],["IP_RECVERR",""],["IP_RECVFRAGSIZE",""],["IP_RECVOPTS",""],["IP_RECVORIGDSTADDR",""],["IP_RECVTOS",""],["IP_RECVTTL",""],["IP_RETOPTS",""],["IP_ROUTER_ALERT",""],["IP_TOS",""],["IP_TRANSPARENT",""],["IP_TTL",""],["IP_UNBLOCK_SOURCE",""],["IP_UNICAST_IF",""],["IP_XFRM_POLICY",""],["LINE_MAX",""],["LINK_MAX",""],["LOGIN_NAME_MAX",""],["LONG_BIT",""],["L_ctermid",""],["L_cuserid",""],["L_tmpnam",""],["MAX_CANON",""],["MAX_INPUT",""],["MB_LEN_MAX",""],["MQ_PRIO_MAX",""],["MSG_BATCH","sendmmsg: more messages coming."],["MSG_CMSG_CLOEXEC","Set close_on_exit for file descriptor received through SCM_RIGHTS."],["MSG_CONFIRM","Confirm path validity."],["MSG_CTRUNC","Control data lost before delivery."],["MSG_DONTROUTE","Don't use local routing."],["MSG_DONTWAIT","Nonblocking IO."],["MSG_EOR","End of record."],["MSG_ERRQUEUE","Fetch message from error queue."],["MSG_FASTOPEN","Send data in TCP SYN."],["MSG_FIN",""],["MSG_MORE","Sender will send more."],["MSG_NOSIGNAL","Do not generate SIGPIPE."],["MSG_OOB","Process out-of-band data."],["MSG_PEEK","Peek at incoming messages."],["MSG_PROXY","Supply or ask second address."],["MSG_RST",""],["MSG_SYN",""],["MSG_TRUNC",""],["MSG_WAITALL","Wait for a full request."],["MSG_WAITFORONE","Wait for at least one packet to return."],["MSG_ZEROCOPY","Use user data in kernel path."],["NAME_MAX",""],["NCBOXCORNER_MASK",""],["NCBOXCORNER_SHIFT",""],["NCBOXGRAD_BOTTOM",""],["NCBOXGRAD_LEFT",""],["NCBOXGRAD_RIGHT",""],["NCBOXGRAD_TOP",""],["NCBOXMASK_BOTTOM",""],["NCBOXMASK_LEFT",""],["NCBOXMASK_RIGHT",""],["NCBOXMASK_TOP",""],["NCDIRECT_OPTION_INHIBIT_CBREAK",""],["NCDIRECT_OPTION_INHIBIT_SETLOCALE",""],["NCKEY_ESC",""],["NCKEY_SPACE",""],["NCMENU_OPTION_BOTTOM",""],["NCMENU_OPTION_HIDING",""],["NCOPTION_INHIBIT_SETLOCALE",""],["NCOPTION_NO_ALTERNATE_SCREEN",""],["NCOPTION_NO_FONT_CHANGES",""],["NCOPTION_NO_QUIT_SIGHANDLERS",""],["NCOPTION_NO_WINCH_SIGHANDLER",""],["NCOPTION_SUPPRESS_BANNERS",""],["NCOPTION_VERIFY_SIXEL",""],["NCPALETTESIZE",""],["NCPLANE_OPTION_HORALIGNED",""],["NCPLOT_OPTION_DETECTMAXONLY",""],["NCPLOT_OPTION_EXPONENTIALD",""],["NCPLOT_OPTION_LABELTICKSD",""],["NCPLOT_OPTION_NODEGRADE",""],["NCPLOT_OPTION_PRINTSAMPLE",""],["NCPLOT_OPTION_VERTICALI",""],["NCPROGBAR_OPTION_RETROGRADE",""],["NCREADER_OPTION_CURSOR",""],["NCREADER_OPTION_HORSCROLL",""],["NCREADER_OPTION_NOCMDKEYS",""],["NCREADER_OPTION_VERSCROLL",""],["NCREEL_OPTION_CIRCULAR",""],["NCREEL_OPTION_INFINITESCROLL",""],["NCSTYLE_BLINK",""],["NCSTYLE_BOLD",""],["NCSTYLE_DIM",""],["NCSTYLE_INVIS",""],["NCSTYLE_ITALIC",""],["NCSTYLE_MASK",""],["NCSTYLE_NONE",""],["NCSTYLE_PROTECT",""],["NCSTYLE_REVERSE",""],["NCSTYLE_STANDOUT",""],["NCSTYLE_STRUCK",""],["NCSTYLE_UNDERLINE",""],["NCVISUAL_OPTION_BLEND",""],["NCVISUAL_OPTION_NODEGRADE",""],["NGROUPS_MAX",""],["NL_ARGMAX",""],["NL_LANGMAX",""],["NR_OPEN",""],["NZERO",""],["PATH_MAX",""],["PF_ALG",""],["PF_APPLETALK",""],["PF_ASH",""],["PF_ATMPVC",""],["PF_ATMSVC",""],["PF_AX25",""],["PF_BLUETOOTH",""],["PF_BRIDGE",""],["PF_CAIF",""],["PF_CAN",""],["PF_DECnet",""],["PF_ECONET",""],["PF_FILE",""],["PF_IB",""],["PF_IEEE802154",""],["PF_INET",""],["PF_INET6",""],["PF_IPX",""],["PF_IRDA",""],["PF_ISDN",""],["PF_IUCV",""],["PF_KCM",""],["PF_KEY",""],["PF_LLC",""],["PF_LOCAL",""],["PF_MAX",""],["PF_MPLS",""],["PF_NETBEUI",""],["PF_NETLINK",""],["PF_NETROM",""],["PF_NFC",""],["PF_PACKET",""],["PF_PHONET",""],["PF_PPPOX",""],["PF_QIPCRTR",""],["PF_RDS",""],["PF_ROSE",""],["PF_ROUTE",""],["PF_RXRPC",""],["PF_SECURITY",""],["PF_SMC",""],["PF_SNA",""],["PF_TIPC",""],["PF_UNIX",""],["PF_UNSPEC",""],["PF_VSOCK",""],["PF_WANPIPE",""],["PF_X25",""],["PF_XDP",""],["PIPE_BUF",""],["PREFIXCOLUMNS",""],["PREFIXSTRLEN",""],["PTHREAD_DESTRUCTOR_ITERATIONS",""],["PTHREAD_KEYS_MAX",""],["PTHREAD_STACK_MIN",""],["PTRDIFF_MAX",""],["PTRDIFF_MIN",""],["P_tmpdir",""],["RAND_MAX",""],["RE_DUP_MAX",""],["RTSIG_MAX",""],["SA_NOCLDSTOP",""],["SA_NOCLDWAIT",""],["SA_SIGINFO",""],["SCM_RIGHTS","Transfer file descriptors."],["SEEK_CUR",""],["SEEK_END",""],["SEEK_SET",""],["SEM_VALUE_MAX",""],["SHUT_RD","No more receptions."],["SHUT_RDWR","No more receptions or transmissions."],["SHUT_WR","No more transmissions."],["SIGABRT",""],["SIGALRM",""],["SIGBUS",""],["SIGCHLD",""],["SIGCLD",""],["SIGCONT",""],["SIGFPE",""],["SIGHUP",""],["SIGILL",""],["SIGINT",""],["SIGIO",""],["SIGIOT",""],["SIGKILL",""],["SIGPIPE",""],["SIGPOLL",""],["SIGPROF",""],["SIGPWR",""],["SIGQUIT",""],["SIGSEGV",""],["SIGSTKFLT",""],["SIGSTOP",""],["SIGSYS",""],["SIGTERM",""],["SIGTRAP",""],["SIGTSTP",""],["SIGTTIN",""],["SIGTTOU",""],["SIGURG",""],["SIGUSR1",""],["SIGUSR2",""],["SIGVTALRM",""],["SIGWINCH",""],["SIGXCPU",""],["SIGXFSZ",""],["SIG_ATOMIC_MAX",""],["SIG_ATOMIC_MIN",""],["SIG_BLOCK",""],["SIG_SETMASK",""],["SIG_UNBLOCK",""],["SIZE_MAX",""],["SOL_AAL",""],["SOL_ALG",""],["SOL_ATM",""],["SOL_BLUETOOTH",""],["SOL_CAIF",""],["SOL_DCCP",""],["SOL_DECNET",""],["SOL_ICMPV6",""],["SOL_IP",""],["SOL_IPV6",""],["SOL_IRDA",""],["SOL_IUCV",""],["SOL_KCM",""],["SOL_LLC",""],["SOL_NETBEUI",""],["SOL_NETLINK",""],["SOL_NFC",""],["SOL_PACKET",""],["SOL_PNPIPE",""],["SOL_PPPOL2TP",""],["SOL_RAW",""],["SOL_RDS",""],["SOL_RXRPC",""],["SOL_SOCKET",""],["SOL_TIPC",""],["SOL_TLS",""],["SOL_X25",""],["SOL_XDP",""],["SOMAXCONN",""],["SO_ACCEPTCONN",""],["SO_BROADCAST",""],["SO_DEBUG",""],["SO_DONTROUTE",""],["SO_ERROR",""],["SO_KEEPALIVE",""],["SO_LINGER",""],["SO_OOBINLINE",""],["SO_RCVBUF",""],["SO_RCVLOWAT",""],["SO_RCVTIMEO",""],["SO_REUSEADDR",""],["SO_SNDBUF",""],["SO_SNDLOWAT",""],["SO_SNDTIMEO",""],["SO_TYPE",""],["TIME_UTC",""],["TMP_MAX",""],["TTY_NAME_MAX",""],["UINT16_MAX",""],["UINT32_MAX",""],["UINT8_MAX",""],["UINTPTR_MAX",""],["UINT_FAST16_MAX",""],["UINT_FAST32_MAX",""],["UINT_FAST8_MAX",""],["UINT_LEAST16_MAX",""],["UINT_LEAST32_MAX",""],["UINT_LEAST8_MAX",""],["WCHAR_MAX_UTF8BYTES",""],["WEOF",""],["WINT_MAX",""],["WINT_MIN",""],["WNOHANG",""],["WORD_BIT",""],["WUNTRACED",""],["XATTR_LIST_MAX",""],["XATTR_NAME_MAX",""],["XATTR_SIZE_MAX",""],["_BITS_BYTESWAP_H",""],["_BITS_ENDIANNESS_H",""],["_BITS_ENDIAN_H",""],["_BITS_POSIX1_LIM_H",""],["_BITS_POSIX2_LIM_H",""],["_BITS_SIGACTION_H",""],["_BITS_SIGNUM_GENERIC_H",""],["_BITS_SIGNUM_H",""],["_BITS_SOCKADDR_H",""],["_BITS_STDINT_INTN_H",""],["_BITS_STDINT_UINTN_H",""],["_BITS_STDIO_LIM_H",""],["_BITS_TIME64_H",""],["_BITS_TIME_H",""],["_BITS_TYPESIZES_H",""],["_BITS_TYPES_H",""],["_BITS_UINTN_IDENTITY_H",""],["_BITS_UIO_LIM_H",""],["_BITS_WCHAR_H",""],["_BITS_WCTYPE_WCHAR_H",""],["_BYTESWAP_H",""],["_CTYPE_H",""],["_ENDIAN_H",""],["_FEATURES_H",""],["_GETOPT_CORE_H",""],["_GETOPT_POSIX_H",""],["_IOFBF",""],["_IOLBF",""],["_IONBF",""],["_IO_EOF_SEEN",""],["_IO_ERR_SEEN",""],["_IO_USER_LOCK",""],["_ISalnum","Alphanumeric."],["_ISalpha","Alphabetic."],["_ISblank","Blank (usually SPC and TAB)."],["_IScntrl","Control character."],["_ISdigit","Numeric."],["_ISgraph","Graphical."],["_ISlower","lowercase."],["_ISprint","Printing."],["_ISpunct","Punctuation."],["_ISspace","Whitespace."],["_ISupper","UPPERCASE."],["_ISwalnum","Alphanumeric."],["_ISwalpha","Alphabetic."],["_ISwblank","Blank (usually SPC and TAB)."],["_ISwcntrl","Control character."],["_ISwdigit","Numeric."],["_ISwgraph","Graphical."],["_ISwlower","lowercase."],["_ISwprint","Printing."],["_ISwpunct","Punctuation."],["_ISwspace","Whitespace."],["_ISwupper","UPPERCASE."],["_ISwxdigit","Hexadecimal numeric."],["_ISxdigit","Hexadecimal numeric."],["_LIBC_LIMITS_H_",""],["_NETINET_IN_H",""],["_NSIG",""],["_POSIX2_BC_BASE_MAX",""],["_POSIX2_BC_DIM_MAX",""],["_POSIX2_BC_SCALE_MAX",""],["_POSIX2_BC_STRING_MAX",""],["_POSIX2_CHARCLASS_NAME_MAX",""],["_POSIX2_COLL_WEIGHTS_MAX",""],["_POSIX2_EXPR_NEST_MAX",""],["_POSIX2_LINE_MAX",""],["_POSIX2_RE_DUP_MAX",""],["_POSIX_AIO_LISTIO_MAX",""],["_POSIX_AIO_MAX",""],["_POSIX_ARG_MAX",""],["_POSIX_CHILD_MAX",""],["_POSIX_CLOCKRES_MIN",""],["_POSIX_C_SOURCE",""],["_POSIX_DELAYTIMER_MAX",""],["_POSIX_FD_SETSIZE",""],["_POSIX_HIWAT",""],["_POSIX_HOST_NAME_MAX",""],["_POSIX_LINK_MAX",""],["_POSIX_LOGIN_NAME_MAX",""],["_POSIX_MAX_CANON",""],["_POSIX_MAX_INPUT",""],["_POSIX_MQ_OPEN_MAX",""],["_POSIX_MQ_PRIO_MAX",""],["_POSIX_NAME_MAX",""],["_POSIX_NGROUPS_MAX",""],["_POSIX_OPEN_MAX",""],["_POSIX_PATH_MAX",""],["_POSIX_PIPE_BUF",""],["_POSIX_QLIMIT",""],["_POSIX_RE_DUP_MAX",""],["_POSIX_RTSIG_MAX",""],["_POSIX_SEM_NSEMS_MAX",""],["_POSIX_SEM_VALUE_MAX",""],["_POSIX_SIGQUEUE_MAX",""],["_POSIX_SOURCE",""],["_POSIX_SSIZE_MAX",""],["_POSIX_STREAM_MAX",""],["_POSIX_SYMLINK_MAX",""],["_POSIX_SYMLOOP_MAX",""],["_POSIX_THREAD_DESTRUCTOR_ITERATIONS",""],["_POSIX_THREAD_KEYS_MAX",""],["_POSIX_THREAD_THREADS_MAX",""],["_POSIX_TIMER_MAX",""],["_POSIX_TTY_NAME_MAX",""],["_POSIX_TZNAME_MAX",""],["_POSIX_UIO_MAXIOV",""],["_SS_SIZE",""],["_STDC_PREDEF_H",""],["_STDINT_H",""],["_STDIO_H",""],["_STDLIB_H",""],["_STRING_H",""],["_STRUCT_TIMESPEC",""],["_SYS_CDEFS_H",""],["_SYS_SOCKET_H",""],["_SYS_TYPES_H",""],["_TIME_H",""],["_UCHAR_H",""],["_WCHAR_H",""],["_WINT_T",""],["_XOPEN_IOV_MAX",""],["_XOPEN_LIM_H",""],["__BIG_ENDIAN",""],["__BIT_TYPES_DEFINED__",""],["__BYTE_ORDER",""],["__FD_SETSIZE",""],["__FILE_defined",""],["__FLOAT_WORD_ORDER",""],["__GLIBC_MINOR__",""],["__GLIBC_USE_DEPRECATED_GETS",""],["__GLIBC_USE_DEPRECATED_SCANF",""],["__GLIBC_USE_IEC_60559_BFP_EXT",""],["__GLIBC_USE_IEC_60559_BFP_EXT_C2X",""],["__GLIBC_USE_IEC_60559_FUNCS_EXT",""],["__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X",""],["__GLIBC_USE_IEC_60559_TYPES_EXT",""],["__GLIBC_USE_ISOC2X",""],["__GLIBC_USE_LIB_EXT2",""],["__GLIBC__",""],["__GNUC_VA_LIST",""],["__GNU_LIBRARY__",""],["__HAVE_DISTINCT_FLOAT128",""],["__HAVE_DISTINCT_FLOAT128X",""],["__HAVE_DISTINCT_FLOAT16",""],["__HAVE_DISTINCT_FLOAT32",""],["__HAVE_DISTINCT_FLOAT32X",""],["__HAVE_DISTINCT_FLOAT64",""],["__HAVE_DISTINCT_FLOAT64X",""],["__HAVE_FLOAT128",""],["__HAVE_FLOAT128X",""],["__HAVE_FLOAT16",""],["__HAVE_FLOAT32",""],["__HAVE_FLOAT32X",""],["__HAVE_FLOAT64",""],["__HAVE_FLOAT64X",""],["__HAVE_FLOAT64X_LONG_DOUBLE",""],["__HAVE_FLOATN_NOT_TYPEDEF",""],["__HAVE_GENERIC_SELECTION",""],["__INO_T_MATCHES_INO64_T",""],["__IOV_MAX",""],["__ISwalnum","Alphanumeric."],["__ISwalpha","Alphabetic."],["__ISwblank","Blank (usually SPC and TAB)."],["__ISwcntrl","Control character."],["__ISwdigit","Numeric."],["__ISwgraph","Graphical."],["__ISwlower","lowercase."],["__ISwprint","Printing."],["__ISwpunct","Punctuation."],["__ISwspace","Whitespace."],["__ISwupper","UPPERCASE."],["__ISwxdigit","Hexadecimal numeric."],["__LITTLE_ENDIAN",""],["__LONG_DOUBLE_USES_FLOAT128",""],["__OFF_T_MATCHES_OFF64_T",""],["__PDP_ENDIAN",""],["__RLIM_T_MATCHES_RLIM64_T",""],["__SIGRTMAX",""],["__SIGRTMIN",""],["__STATFS_MATCHES_STATFS64",""],["__STDC_IEC_559_COMPLEX__",""],["__STDC_IEC_559__",""],["__STDC_ISO_10646__",""],["__SYSCALL_WORDSIZE",""],["__TIMESIZE",""],["__USE_FORTIFY_LEVEL",""],["__USE_ISOC11",""],["__USE_ISOC95",""],["__USE_ISOC99",""],["__USE_KERNEL_IPV6_DEFS",""],["__USE_POSIX",""],["__USE_POSIX2",""],["__USE_POSIX_IMPLICITLY",""],["__USE_XOPEN",""],["__WALL",""],["__WCLONE",""],["__WCOREFLAG",""],["__WNOTHREAD",""],["__WORDSIZE",""],["__WORDSIZE_TIME64_COMPAT32",""],["__W_CONTINUED",""],["____FILE_defined",""],["_____fpos64_t_defined",""],["_____fpos_t_defined",""],["____mbstate_t_defined",""],["__bool_true_false_are_defined",""],["__clock_t_defined",""],["__clockid_t_defined",""],["__glibc_c99_flexarr_available",""],["__iovec_defined",""],["__ldiv_t_defined",""],["__lldiv_t_defined",""],["__mbstate_t_defined",""],["__sig_atomic_t_defined",""],["__sigset_t_defined",""],["__socket_type_SOCK_CLOEXEC","Atomically set close-on-exec flag for the new descriptor(s)."],["__socket_type_SOCK_DCCP","Datagram Congestion Control Protocol."],["__socket_type_SOCK_DGRAM","Connectionless, unreliable datagrams of fixed maximum length."],["__socket_type_SOCK_NONBLOCK","Atomically mark descriptor(s) as non-blocking."],["__socket_type_SOCK_PACKET","Linux specific way of getting packets at the dev level.  For writing rarp and other similar things on the user level."],["__socket_type_SOCK_RAW","Raw protocol interface."],["__socket_type_SOCK_RDM","Reliably-delivered messages."],["__socket_type_SOCK_SEQPACKET","Sequenced, reliable, connection-based, datagrams of fixed maximum length."],["__socket_type_SOCK_STREAM","Sequenced, reliable, connection-based byte streams."],["__struct_FILE_defined",""],["__struct_tm_defined",""],["__time_t_defined",""],["__timer_t_defined",""],["__wint_t_defined",""],["false_",""],["ncalign_e_NCALIGN_CENTER",""],["ncalign_e_NCALIGN_LEFT",""],["ncalign_e_NCALIGN_RIGHT",""],["ncalign_e_NCALIGN_UNALIGNED",""],["ncblitter_e_NCBLIT_1x1","space, compatible with ASCII"],["ncblitter_e_NCBLIT_2x1","halves + 1x1 (space)     ▄▀"],["ncblitter_e_NCBLIT_2x2","quadrants + 2x1          ▗▐ ▖▀▟▌▙"],["ncblitter_e_NCBLIT_3x2","sextants (NOT 2x2)     🬀🬁🬂🬃🬄🬅🬆🬇🬈🬉🬊🬋🬌🬍🬎🬏🬐🬑🬒🬓🬔🬕🬖🬗🬘🬙🬚🬛🬜🬝🬞🬟🬠🬡🬢🬣🬤🬥🬦🬧🬨🬩🬪🬫🬬🬭🬮🬯🬰🬱🬲🬳🬴🬵🬶🬷🬸🬹🬺🬻"],["ncblitter_e_NCBLIT_4x1","four vertical levels     █▆▄▂"],["ncblitter_e_NCBLIT_8x1","eight vertical levels    █▇▆▅▄▃▂▁"],["ncblitter_e_NCBLIT_BRAILLE","4 rows, 2 cols (braille) ⡀⡄⡆⡇⢀⣀⣄⣆⣇⢠⣠⣤⣦⣧⢰⣰⣴⣶⣷⢸⣸⣼⣾⣿"],["ncblitter_e_NCBLIT_DEFAULT","let the ncvisual pick"],["ncblitter_e_NCBLIT_SIXEL","not yet implemented"],["ncloglevel_e_NCLOGLEVEL_DEBUG","this is honestly a bit much"],["ncloglevel_e_NCLOGLEVEL_ERROR","we can't keep doin' this, but we can do other things"],["ncloglevel_e_NCLOGLEVEL_FATAL","we're hanging around, but we've had a horrible fault"],["ncloglevel_e_NCLOGLEVEL_INFO","\"standard information\""],["ncloglevel_e_NCLOGLEVEL_PANIC","print diagnostics immediately related to crashing"],["ncloglevel_e_NCLOGLEVEL_SILENT","default. print nothing once fullscreen service begins"],["ncloglevel_e_NCLOGLEVEL_TRACE","there's probably a better way to do what you want"],["ncloglevel_e_NCLOGLEVEL_VERBOSE","\"detailed information\""],["ncloglevel_e_NCLOGLEVEL_WARNING","you probably don't want what's happening to happen"],["ncscale_e_NCSCALE_NONE",""],["ncscale_e_NCSCALE_SCALE",""],["ncscale_e_NCSCALE_STRETCH",""],["true_",""]],"fn":[["_Exit","Terminate the program with STATUS without calling any of the functions registered with `atexit' or `on_exit'."],["__cmsg_nxthdr",""],["__ctype_b_loc","These are defined in ctype-info.c. The declarations here must match those in localeinfo.h."],["__ctype_get_mb_cur_max",""],["__ctype_tolower_loc",""],["__ctype_toupper_loc",""],["__libc_current_sigrtmax","Return number of available real-time signal with lowest priority."],["__libc_current_sigrtmin","Return number of available real-time signal with highest priority."],["__mbrlen","Return number of bytes in multibyte character pointed to by S."],["__overflow",""],["__strtok_r","Divide S into tokens separated by characters in DELIM.  Information passed between calls are stored in SAVE_PTR."],["__sysconf","Even though CLOCKS_PER_SEC has such a strange value CLK_TCK presents the real value for clock ticks per second for the system."],["__sysv_signal","The X/Open definition of `signal' specifies the SVID semantic.  Use the additional function `sysv_signal' when X/Open compatibility is requested."],["__uflow","Slow-path routines used by the optimized inline functions in bits/stdio.h."],["_tolower",""],["_toupper",""],["abort","Abort execution and generate a core-dump."],["abs","Return the absolute value of X."],["accept","Await a connection on socket FD. When a connection arrives, open a new socket to communicate with it, set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting peer and *ADDR_LEN to the address's actual length, and return the new socket's descriptor, or -1 for errors."],["aligned_alloc","ISO C variant of aligned allocation."],["asctime","Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\" that is the representation of TP in this format."],["asctime_r","Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\" that is the representation of TP in this format."],["at_quick_exit",""],["atexit","Register a function to be called when `exit' is called."],["atof","Convert a string to a floating-point number."],["atoi","Convert a string to an integer."],["atol","Convert a string to a long integer."],["atoll","Convert a string to a long long integer."],["bind","Give the socket FD the local address ADDR (which is LEN bytes long)."],["bsearch","Do a binary search for KEY in BASE, which consists of NMEMB elements of SIZE bytes each, using COMPAR to perform the comparisons."],["btowc","Determine whether C constitutes a valid (one-byte) multibyte character."],["c16rtomb","Write multibyte representation of char16_t C16 to S."],["c32rtomb","Write multibyte representation of char32_t C32 to S."],["calloc","Allocate NMEMB elements of SIZE bytes each, all initialized to 0."],["cell_duplicate","Duplicate 'c' into 'targ'; both must be/will be bound to 'n'."],["cell_extended_gcluster","return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer can be invalidated by any further operation on the plane 'n', so...watch out!"],["cell_load","Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'. Returns the number of bytes copied out of 'gcluster', or -1 on failure. The styling of the cell is left untouched, but any resources are released."],["cell_release","Release resources held by the nccell 'c'."],["cells_double_box",""],["cells_rounded_box",""],["clearerr","Clear the error and EOF indicators for STREAM."],["clock","Time used by the program so far (user time + system time). The result / CLOCKS_PER_SEC is program time in seconds."],["connect","Open a connection on socket FD to peer at ADDR (which LEN bytes long). For connectionless socket types, just set the default address to send to and the only address from which to accept transmissions. Return 0 on success, -1 for errors."],["ctermid","Return the name of the controlling terminal."],["ctime","Equivalent to `asctime (localtime (timer))'."],["ctime_r","Equivalent to `asctime_r (localtime_r (timer, TMP), buf)'."],["cuserid","Return the name of the current user."],["difftime","Return the difference between TIME1 and TIME0."],["div","Return the `div_t', `ldiv_t' or `lldiv_t' representation of the value of NUMER over DENOM. */"],["drand48","Return non-negative, double-precision floating-point value in [0.0,1.0)."],["erand48",""],["exit","Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered, perform stdio cleanup, and terminate program execution with STATUS."],["fclose","Close STREAM."],["fdopen","Create a new stream that refers to an existing system file descriptor."],["feof","Return the EOF indicator for STREAM."],["ferror","Return the error indicator for STREAM."],["fflush","Flush STREAM, or all streams if STREAM is NULL."],["fgetc","Read a character from STREAM."],["fgetpos","Get STREAM's position."],["fgets","Get a newline-terminated string of finite length from STREAM."],["fgetwc","Read a character from STREAM."],["fgetws","Get a newline-terminated wide character string of finite length from STREAM."],["fileno","Return the system file descriptor for STREAM."],["fopen","Open a file and create a new stream for it."],["fprintf","Write formatted output to STREAM."],["fputc","Write a character to STREAM."],["fputs","Write a string to STREAM."],["fputwc","Write a character to STREAM."],["fputws","Write a string to STREAM."],["fread","Read chunks of generic data from STREAM."],["free","Free a block allocated by `malloc', `realloc' or `calloc'."],["freopen","Open a file, replacing an existing stream with it."],["fscanf","Read formatted input from STREAM."],["fscanf1","Read formatted input from STREAM."],["fseek","Seek to a certain position on STREAM."],["fsetpos","Set STREAM's position."],["ftell","Return the current position of STREAM."],["fwide","Select orientation for stream."],["fwprintf","Write formatted output to STREAM."],["fwrite","Write chunks of generic data to STREAM."],["fwscanf","Read formatted input from STREAM."],["fwscanf1","Read formatted input from STREAM."],["getc",""],["getchar","Read a character from stdin."],["getenv","Return the value of envariable NAME, or NULL if it doesn't exist."],["getopt","Get definitions and prototypes for functions to process the arguments in ARGV (ARGC of them, minus the program name) for options given in OPTS."],["getpeername","Put the address of the peer connected to socket FD into *ADDR (which is *LEN bytes long), and its actual length into *LEN."],["getsockname","Put the local address of FD into *ADDR and its length in *LEN."],["getsockopt","Put the current value for socket FD's option OPTNAME at protocol level LEVEL into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's actual length.  Returns 0 on success, -1 for errors."],["getw","Get a word (int) from STREAM."],["getwc",""],["getwchar","Read a character from stdin."],["gmtime","Return the `struct tm' representation of *TIMER in Universal Coordinated Time (aka Greenwich Mean Time)."],["gmtime_r","Return the `struct tm' representation of *TIMER in UTC, using *TP to store the result."],["htonl",""],["htons",""],["isalnum",""],["isalpha",""],["isascii","Return nonzero iff C is in the ASCII set (i.e., is no more than 7 bits wide)."],["isblank",""],["iscntrl",""],["isdigit",""],["isgraph",""],["islower",""],["isprint",""],["ispunct",""],["isspace",""],["isupper",""],["iswalnum","Test for any wide character for which `iswalpha' or `iswdigit' is true."],["iswalpha","Test for any wide character for which `iswupper' or 'iswlower' is true, or any wide character that is one of a locale-specific set of wide-characters for which none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."],["iswblank",""],["iswcntrl","Test for any control wide character."],["iswctype","Determine whether the wide-character WC has the property described by DESC."],["iswdigit","Test for any wide character that corresponds to a decimal-digit character."],["iswgraph","Test for any wide character for which `iswprint' is true and `iswspace' is false."],["iswlower","Test for any wide character that corresponds to a lowercase letter or is one of a locale-specific set of wide characters for which none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."],["iswprint","Test for any printing wide character."],["iswpunct","Test for any printing wide character that is one of a locale-specific et of wide characters for which neither `iswspace' nor `iswalnum' is true."],["iswspace","Test for any wide character that corresponds to a locale-specific set of wide characters for which none of `iswalnum', `iswgraph', or `iswpunct' is true."],["iswupper","Test for any wide character that corresponds to an uppercase letter or is one of a locale-specific set of wide character for which none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."],["iswxdigit","Test for any wide character that corresponds to a hexadecimal-digit character equivalent to that performed be the functions described in the previous subclause."],["isxdigit",""],["jrand48",""],["kill",""],["labs",""],["lcong48",""],["ldiv",""],["listen","Prepare to accept connections on socket FD. N connection requests will be queued before further requests are refused. Returns 0 on success, -1 for errors."],["llabs",""],["lldiv",""],["localtime","Return the `struct tm' representation of *TIMER in the local timezone."],["localtime_r","Return the `struct tm' representation of *TIMER in local time, using *TP to store the result."],["lrand48","Return non-negative, long integer in [0,2^31)."],["malloc","Allocate SIZE bytes of memory."],["mblen","Return the length of the multibyte character in S, which is no longer than N."],["mbrlen",""],["mbrtoc16","Write char16_t representation of multibyte character pointed to by S to PC16."],["mbrtoc32","Write char32_t representation of multibyte character pointed to by S to PC32."],["mbrtowc","Write wide character representation of multibyte character pointed to by S to PWC."],["mbsinit","Determine whether PS points to an object representing the initial state."],["mbsrtowcs","Write wide character representation of multibyte character string SRC to DST."],["mbstowcs","Convert a multibyte string to a wide char string."],["mbtowc","Return the length of the given multibyte character, putting its `wchar_t' representation in *PWC."],["memccpy",""],["memchr",""],["memcmp","Compare N bytes of S1 and S2."],["memcpy","Copy N bytes of SRC to DEST."],["memmove","Copy N bytes of SRC to DEST, guaranteeing correct behavior for overlapping strings."],["memset","Set N bytes of S to C."],["mktime","Return the `time_t' representation of TP and normalize TP."],["mrand48","Return signed, long integers in [-2^31,2^31)."],["ncblit_bgrx","Same as ncblit_rgba(), but for BGRx."],["ncblit_rgba","Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n', which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative to the specified plane. Each source row ought occupy 'linesize' bytes (this might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A subregion of the input can be specified with the 'begy'x'begx' and 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or -1 on error."],["ncdirect_bg_default",""],["ncdirect_bg_palindex",""],["ncdirect_bg_rgb",""],["ncdirect_box","Draw a box with its upper-left corner at the current cursor position, having dimensions |ylen|x|xlen|. See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an array of 6 wide characters: UL, UR, LL, LR, HL, VL."],["ncdirect_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["ncdirect_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["ncdirect_clear","Clear the screen."],["ncdirect_cursor_disable",""],["ncdirect_cursor_down",""],["ncdirect_cursor_enable",""],["ncdirect_cursor_left",""],["ncdirect_cursor_move_yx","Move the cursor in direct mode. -1 to retain current location on that axis."],["ncdirect_cursor_pop",""],["ncdirect_cursor_push","Push or pop the cursor location to the terminal's stack. The depth of this stack, and indeed its existence, is terminal-dependent."],["ncdirect_cursor_right",""],["ncdirect_cursor_up",""],["ncdirect_cursor_yx","Get the cursor position, when supported. This requires writing to the terminal, and then reading from it. If the terminal doesn't reply, or doesn't reply in a way we understand, the results might be deleterious."],["ncdirect_dim_x","Get the current number of columns/rows."],["ncdirect_dim_y",""],["ncdirect_double_box","ncdirect_box() with the double box-drawing characters"],["ncdirect_fg_default",""],["ncdirect_fg_palindex",""],["ncdirect_fg_rgb","Direct mode. This API can be used to colorize and stylize output generated outside of notcurses, without ever calling notcurses_render(). These should not be intermixed with standard Notcurses rendering."],["ncdirect_flush","Force a flush. Returns 0 on success, -1 on failure."],["ncdirect_getc","See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking operation, and otherwise a timespec to bound blocking. Signals in sigmask (less several we handle internally) will be atomically masked and unmasked per ppoll(2). '*sigmask' should generally contain all signals. Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the return value is the 'id' field from that event. 'ni' may be NULL."],["ncdirect_hline_interp","Draw horizontal/vertical lines using the specified channels, interpolating between them as we go. The EGC may not use more than one column. For a horizontal line, |len| cannot exceed the screen width minus the cursor's offset. For a vertical line, it may be as long as you'd like; the screen will scroll as necessary. All lines start at the current cursor position."],["ncdirect_init","Initialize a direct-mode Notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually want stdout. Direct mode supports a limited subset of Notcurses routines which directly affect 'fp', and neither supports nor requires notcurses_render(). This can be used to add color and styling to text in the standard output paradigm. 'flags' is a bitmask over NCDIRECT_OPTION_*. Returns NULL on error, including any failure initializing terminfo."],["ncdirect_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call ncdirect_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["ncdirect_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["ncdirect_printf_aligned","Formatted printing (plus alignment relative to the terminal). Returns the number of columns printed on success."],["ncdirect_putstr","Output the string |utf8| according to the channels |channels|. Note that ncdirect_putstr() does not explicitly flush output buffers, so it will not necessarily be immediately visible."],["ncdirect_render_image","Display an image using the specified blitter and scaling. The image may be arbitrarily many rows -- the output will scroll -- but will only occupy the column of the cursor, and those to the right."],["ncdirect_rounded_box","ncdirect_box() with the rounded box-drawing characters"],["ncdirect_stop","Release 'nc' and any associated resources. 0 on success, non-0 on failure."],["ncdirect_styles_off",""],["ncdirect_styles_on",""],["ncdirect_styles_set","ncplane_styles_*() analogues"],["ncdirect_vline_interp",""],["ncdplot_add_sample",""],["ncdplot_create",""],["ncdplot_destroy",""],["ncdplot_plane",""],["ncdplot_sample",""],["ncdplot_set_sample",""],["ncfadectx_free","Release the resources associated with 'nctx'."],["ncfadectx_iterations","Return the number of iterations through which 'nctx' will fade."],["ncfadectx_setup","Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."],["ncfdplane_create","Create an ncfdplane around the fd 'fd'. Consider this function to take ownership of the file descriptor, which will be closed in ncfdplane_destroy()."],["ncfdplane_destroy",""],["ncfdplane_plane",""],["ncmenu_create","Create a menu with the specified options. Menus are currently bound to an overall Notcurses object (as opposed to a particular plane), and are implemented as ncplanes kept atop other ncplanes."],["ncmenu_destroy","Destroy a menu created with ncmenu_create()."],["ncmenu_item_set_status","Disable or enable a menu item. Returns 0 if the item was found."],["ncmenu_mouse_selected","Return the item description corresponding to the mouse click 'click'. The item must be on an actively unrolled section, and the click must be in the area of a valid item. If 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled in with the shortcut."],["ncmenu_nextitem","Move to the previous/next item within the currently unrolled section. If no section is unrolled, the first section will be unrolled."],["ncmenu_nextsection","Unroll the previous/next section (relative to current unrolled). If no section is unrolled, the first section will be unrolled."],["ncmenu_offer_input","Offer the input to the ncmenu. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the menu, false is returned. Relevant inputs include:"],["ncmenu_plane","Return the ncplane backing this ncmenu."],["ncmenu_previtem",""],["ncmenu_prevsection",""],["ncmenu_rollup","Roll up any unrolled menu section, and hide the menu if using hiding."],["ncmenu_selected","Return the selected item description, or NULL if no section is unrolled. If 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled in with that shortcut--this can allow faster matching."],["ncmenu_unroll","Unroll the specified menu section, making the menu visible if it was invisible, and rolling up any menu section that is already unrolled."],["ncmetric","Takes an arbitrarily large number, and prints it into a fixed-size buffer by adding the necessary SI suffix. Usually, pass a |[IB]PREFIXSTRLEN+1|-sized buffer to generate up to |[IB]PREFIXCOLUMNS| columns' worth of EGCs. The characteristic can occupy up through |mult-1| characters (3 for 1000, 4 for 1024). The mantissa can occupy either zero or two characters."],["ncmultiselector_create",""],["ncmultiselector_destroy","Destroy the ncmultiselector."],["ncmultiselector_offer_input","Offer the input to the ncmultiselector. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the multiselector, false is returned. Relevant inputs include:"],["ncmultiselector_plane","Return a reference to the ncmultiselector's underlying ncplane."],["ncmultiselector_selected","Return selected vector. An array of bools must be provided, along with its length. If that length doesn't match the itemcount, it is an error."],["ncpile_bottom","Return the bottommost plane of the pile containing 'n'."],["ncpile_create","Same as ncplane_create(), but creates a new pile. The returned plane will be the top, bottom, and root of this new pile."],["ncpile_rasterize","Make the physical screen match the last rendered frame from the pile of which 'n' is a part. This is a blocking call. Don't call this before the pile has been rendered (doing so will likely result in a blank screen)."],["ncpile_render","Renders the pile of which 'n' is a part. Rendering this pile again will blow away the render. To actually write out the render, call ncpile_rasterize()."],["ncpile_top","Return the topmost plane of the pile containing 'n'."],["ncplane_above",""],["ncplane_at_cursor","Retrieve the current contents of the cell under the cursor. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["ncplane_at_yx","Retrieve the current contents of the specified cell. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["ncplane_base","Extract the ncplane's base nccell into 'c'. The reference is invalidated if 'ncp' is destroyed."],["ncplane_below","Return the plane below this one, or NULL if this is at the bottom."],["ncplane_box","Draw a box with its upper-left corner at the current cursor position, and its lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the upper-left, ur, ll, and lr corners, then the horizontal and vertical lines. 'ctlword' is defined in the least significant byte, where bits [7, 4] are a gradient mask, and [3, 0] are a border mask:"],["ncplane_center_abs",""],["ncplane_channels","Get the current channels or attribute word for ncplane 'n'."],["ncplane_contents","Create a flat string from the EGCs of the selected region of the ncplane 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and 'lenx' can be specified as -1 to go through the boundary of the plane."],["ncplane_create","Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to the origin of 'n') and the specified size. The number of 'rows' and 'cols' must both be positive. This plane is initially at the top of the z-buffer, as if ncplane_move_top() had been called on it. The void* 'userptr' can be retrieved (and reset) later. A 'name' can be set, used in debugging."],["ncplane_cursor_move_yx","Move the cursor to the specified position (the cursor needn't be visible). Returns -1 on error, including negative parameters, or ones exceeding the plane's dimensions."],["ncplane_cursor_yx","Get the current position of the cursor within n. y and/or x may be NULL."],["ncplane_destroy","Destroy the specified ncplane. None of its contents will be visible after the next call to notcurses_render(). It is an error to attempt to destroy the standard plane."],["ncplane_dim_yx","Return the dimensions of this ncplane."],["ncplane_dup","Duplicate an existing ncplane. The new plane will have the same geometry, will duplicate all content, and will start with the same rendering state. The new plane will be immediately above the old one on the z axis, and will be bound to the same parent. Bound planes are not duplicated; the new plane is bound to the parent of 'n', but has no bound planes."],["ncplane_erase","Erase every cell in the ncplane (each cell is initialized to the null glyph and the default channels/styles). All cells associated with this ncplane are invalidated, and must not be used after the call, excluding the base cell. The cursor is homed. The plane's active attributes are unaffected."],["ncplane_fadein","Fade the ncplane in over the specified time. Load the ncplane with the target cells without rendering, then call this function. When it's done, the ncplane will have reached the target levels, starting from zeroes."],["ncplane_fadein_iteration","Fade in through 'iter' iterations, where 'iter' < 'ncfadectx_iterations(nctx)'."],["ncplane_fadeout","Fade the ncplane out over the provided time, calling 'fader' at each iteration. Requires a terminal which supports truecolor, or at least palette modification (if the terminal uses a palette, our ability to fade planes is limited, and affected by the complexity of the rest of the screen)."],["ncplane_fadeout_iteration","Fade out through 'iter' iterations, where 'iter' < 'ncfadectx_iterations(nctx)'."],["ncplane_format","Set the given style throughout the specified region, keeping content and channels unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_gradient","Draw a gradient with its upper-left corner at the current cursor position, stopping at 'ystop'x'xstop'. The glyph composed of 'egc' and 'stylemask' is used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr' are composed into foreground and background gradients. To do a vertical gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To color everything the same, all four channels should be equivalent. The resulting alpha values are equal to incoming alpha values. Returns the number of cells filled on success, or -1 on failure."],["ncplane_greyscale","Convert the plane's content to greyscale."],["ncplane_highgradient","Do a high-resolution gradient using upper blocks and synced backgrounds. This doubles the number of vertical gradations, but restricts you to half blocks (appearing to be full blocks). Returns the number of cells filled on success, or -1 on error."],["ncplane_highgradient_sized","ncplane_gradent_sized() meets ncplane_highgradient()."],["ncplane_hline_interp","Draw horizontal or vertical lines using the specified cell, starting at the current cursor position. The cursor will end at the cell following the last cell output (even, perhaps counter-intuitively, when drawing vertical lines), just as if ncplane_putc() was called at that spot. Return the number of cells drawn on success. On error, return the negative number of cells drawn."],["ncplane_home","Move the cursor to 0, 0. Can't fail."],["ncplane_mergedown","Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously defined as \"write to 'dst' the frame that would be rendered were the entire stack made up only of the specified subregion of 'src' and, below it, the subregion of 'dst' having the specified origin. Merging is independent of the position of 'src' viz 'dst' on the z-axis. It is an error to define a subregion of zero area, or that is not entirely contained within 'src'. It is an error to define a target origin such that the projected subregion is not entirely contained within 'dst'.  Behavior is undefined if 'src' and 'dst' are equivalent. 'dst' is modified, but 'src' remains unchanged."],["ncplane_mergedown_simple","If 'src' does not intersect with 'dst', 'dst' will not be changed, but it is not an error. If 'dst' is NULL, the operation will target the standard plane."],["ncplane_move_above","Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'. Returns non-zero if 'n' is already in the desired location. 'n' and 'above' must not be the same plane."],["ncplane_move_below","Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'. Returns non-zero if 'n' is already in the desired location. 'n' and 'below' must not be the same plane."],["ncplane_move_bottom",""],["ncplane_move_top","Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom."],["ncplane_move_yx","Move this plane relative to the standard plane, or the plane to which it is bound (if it is bound to a plane). It is an error to attempt to move the standard plane."],["ncplane_new","This function will be removed in 3.0 in favor of ncplane_create(). It persists in 2.0 only for backwards compatibility."],["ncplane_notcurses","Extract the Notcurses context to which this plane is attached."],["ncplane_notcurses_const",""],["ncplane_off_styles","Remove the specified styles from the ncplane's existing spec."],["ncplane_on_styles","Add the specified styles to the ncplane's existing spec."],["ncplane_parent","Get the plane to which the plane 'n' is bound, if any."],["ncplane_parent_const",""],["ncplane_polyfill_yx","Starting at the specified coordinate, if its glyph is different from that of 'c', 'c' is copied into it, and the original glyph is considered the fill target. We do the same to all cardinally-connected cells having this same fill target. Returns the number of cells polyfilled. An invalid initial y, x is an error. Returns the number of cells filled, or -1 on error."],["ncplane_pulse","Pulse the plane in and out until the callback returns non-zero, relying on the callback 'fader' to initiate rendering. 'ts' defines the half-period (i.e. the transition from black to full brightness, or back again). Proper use involves preparing (but not rendering) an ncplane, then calling ncplane_pulse(), which will fade in from black to the specified colors."],["ncplane_putc_yx","Replace the cell at the specified coordinates with the provided cell 'c', and advance the cursor by the width of the cell (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. 'c' must already be associated with 'n'. On failure, -1 is returned."],["ncplane_putchar_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putegc_yx","Replace the cell at the specified coordinates with the provided EGC, and advance the cursor by the width of the cluster (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. On failure, -1 is returned. The number of bytes converted from gclust is written to 'sbytes' if non-NULL."],["ncplane_putnstr_aligned",""],["ncplane_putnstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error. No more than 's' bytes will be written."],["ncplane_putstr_aligned",""],["ncplane_putstr_stained","Replace a string's worth of glyphs at the current cursor location, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error."],["ncplane_puttext","Write the specified text to the plane, breaking lines sensibly, beginning at the specified line. Returns the number of columns written. When breaking a line, the line will be cleared to the end of the plane (the last line will not be so cleared). The number of bytes written from the input is written to '*bytes' if it is not NULL. Cleared columns are included in the return value, but not included in the number of bytes written. Leaves the cursor at the end of output. A partial write will be accomplished as far as it can; determine whether the write completed by inspecting '*bytes'. Can output to multiple rows even in the absence of scrolling, but not more rows than are available. With scrolling enabled, arbitrary amounts of data can be emitted. All provided whitespace is preserved -- ncplane_puttext() followed by an appropriate ncplane_contents() will read back the original output."],["ncplane_putwegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putwstr_stained",""],["ncplane_qrcode","Draw a QR code at the current position on the plane. If there is insufficient room to draw the code here, or there is any other error, non-zero will be returned. Otherwise, the QR code \"version\" (size) is returned. The QR code is (version * 4 + 17) columns wide, and ⌈version * 4 + 17⌉ rows tall (the properly-scaled values are written back to '*ymax' and '*xmax')."],["ncplane_reparent","Plane 'n' will be unbound from its parent plane, and will be made a bound child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n' is already the root of a pile, in which case this is a no-op. Returns 'n'. The standard plane cannot be reparented. Any planes bound to 'n' are reparented to the previous parent of 'n'."],["ncplane_reparent_family","The same as ncplane_reparent(), except any planes bound to 'n' come along with it to its new destination. Their z-order is maintained. If 'newparent' is an ancestor of 'n', NULL is returned, and no changes are made."],["ncplane_resize","Resize the specified ncplane. The four parameters 'keepy', 'keepx', 'keepleny', and 'keeplenx' define a subset of the ncplane to keep, unchanged. This may be a section of size 0, though none of these four parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane. They must specify a coordinate within the ncplane's totality. 'yoff' and 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny', and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx' is non-zero, both must be non-zero."],["ncplane_resize_maximize","Suitable for use as a 'resizecb', this will resize the plane to the visual region's size. It is used for the standard plane."],["ncplane_resize_realign","Suitable for use as a 'resizecb'. This will realign the plane 'n' against its parent, using the alignment specified at ncplane_create()-time."],["ncplane_resizecb","Returns the ncplane's current resize callback."],["ncplane_rgba","Create an RGBA flat array from the selected region of the ncplane 'nc'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and 'lenx' can be specified as -1 to go through the boundary of the plane. Only glyphs from the specified blitset may be present."],["ncplane_rotate_ccw",""],["ncplane_rotate_cw","Rotate the plane π/2 radians clockwise or counterclockwise. This cannot be performed on arbitrary planes, because glyphs cannot be arbitrarily rotated. The glyphs which can be rotated are limited: line-drawing characters, spaces, half blocks, and full blocks. The plane must have an even number of columns. Use the ncvisual rotation for a more flexible approach."],["ncplane_set_base","Set the ncplane's base nccell to this cell. It will be used for purposes of rendering anywhere that the ncplane's gcluster is 0. Erasing the ncplane does not reset the base cell; this function must be called with an empty 'egc'. 'egc' must be a single extended grapheme cluster."],["ncplane_set_base_cell","Set the ncplane's base nccell to this nccell. It will be used for purposes of rendering anywhere that the ncplane's gcluster is 0. Erasing the ncplane does not reset the base cell; this function must be called with a zero 'c'."],["ncplane_set_bchannel",""],["ncplane_set_bg_alpha",""],["ncplane_set_bg_default",""],["ncplane_set_bg_palindex",""],["ncplane_set_bg_rgb",""],["ncplane_set_bg_rgb8",""],["ncplane_set_bg_rgb8_clipped","Same, but clipped to [0..255]."],["ncplane_set_channels",""],["ncplane_set_fchannel","Set an entire 32-bit channel of the plane"],["ncplane_set_fg_alpha","Set the alpha parameters for ncplane 'n'."],["ncplane_set_fg_default","Use the default color for the foreground/background."],["ncplane_set_fg_palindex","Set the ncplane's foreground palette index, set the foreground palette index bit, set it foreground-opaque, and clear the foreground default color bit."],["ncplane_set_fg_rgb","Same, but with rgb assembled into a channel (i.e. lower 24 bits)."],["ncplane_set_fg_rgb8","Set the current fore/background color using RGB specifications. If the terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\", indicated by the \"RGB\" terminfo capability), the provided values will be interpreted in some lossy fashion. None of r, g, or b may exceed 255. \"HP-like\" terminals require setting foreground and background at the same time using \"color pairs\"; Notcurses will manage color pairs transparently."],["ncplane_set_fg_rgb8_clipped",""],["ncplane_set_resizecb","Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL). The standard plane's resizecb may not be changed."],["ncplane_set_scrolling","All planes are created with scrolling disabled. Scrolling can be dynamically controlled with ncplane_set_scrolling(). Returns true if scrolling was previously enabled, or false if it was disabled."],["ncplane_set_styles","Set the specified style bits for the ncplane 'n', whether they're actively supported or not."],["ncplane_set_userptr","Manipulate the opaque user pointer associated with this plane. ncplane_set_userptr() returns the previous userptr after replacing it with 'opaque'. the others simply return the userptr."],["ncplane_stain","Set the given channels throughout the specified region, keeping content and attributes unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_styles","Return the current styling for this ncplane."],["ncplane_styles_off",""],["ncplane_styles_on",""],["ncplane_styles_set","Deprecated forms of above."],["ncplane_translate","provided a coordinate relative to the origin of 'src', map it to the same absolute coordinate relative to thte origin of 'dst'. either or both of 'y' and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."],["ncplane_translate_abs","Fed absolute 'y'/'x' coordinates, determine whether that coordinate is within the ncplane 'n'. If not, return false. If so, return true. Either way, translate the absolute coordinates relative to 'n'. If the point is not within 'n', these coordinates will not be within the dimensions of the plane."],["ncplane_userptr",""],["ncplane_vline_interp",""],["ncplane_vprintf_aligned","The ncplane equivalents of printf(3) and vprintf(3)."],["ncplane_vprintf_stained",""],["ncplane_vprintf_yx",""],["ncplane_x",""],["ncplane_y",""],["ncplane_yx","Get the origin of this plane relative to the standard plane, or the plane to which it is bound (if it is bound to a plane)."],["ncprogbar_create","Takes ownership of the ncplane 'n', which will be destroyed by ncprogbar_destroy(). The progress bar is initially at 0%."],["ncprogbar_destroy","Destroy the progress bar and its underlying ncplane."],["ncprogbar_plane","Return a reference to the ncprogbar's underlying ncplane."],["ncprogbar_progress","Get the progress bar's completion, a double on [0, 1]."],["ncprogbar_set_progress","Set the progress bar's completion, a double 0 <= 'p' <= 1."],["ncreader_clear","empty the ncreader of any user input, and home the cursor."],["ncreader_contents","return a heap-allocated copy of the current (UTF-8) contents."],["ncreader_create","ncreaders provide freeform input in a (possibly multiline) region, supporting optional readline keybindings. takes ownership of 'n', destroying it on any error (ncreader_destroy() otherwise destroys the ncplane)."],["ncreader_destroy","destroy the reader and its bound plane. if 'contents' is not NULL, the UTF-8 input will be heap-duplicated and written to 'contents'."],["ncreader_move_down",""],["ncreader_move_left","Atttempt to move in the specified direction. Returns 0 if a move was successfully executed, -1 otherwise. Scrolling is taken into account."],["ncreader_move_right",""],["ncreader_move_up",""],["ncreader_offer_input","Offer the input to the ncreader. If it's relevant, this function returns true, and the input ought not be processed further. Almost all inputs are relevant to an ncreader, save synthesized ones."],["ncreader_plane",""],["ncreader_write_egc","Destructively write the provided EGC to the current cursor location. Move the cursor as necessary, scrolling if applicable."],["ncreel_add","Add a new nctablet to the provided ncreel 'nr', having the callback object 'opaque'. Neither, either, or both of 'after' and 'before' may be specified. If neither is specified, the new tablet can be added anywhere on the reel. If one or the other is specified, the tablet will be added before or after the specified tablet. If both are specified, the tablet will be added to the resulting location, assuming it is valid (after->next == before->prev); if it is not valid, or there is any other error, NULL will be returned."],["ncreel_create","Take over the ncplane 'nc' and use it to draw a reel according to 'popts'. The plane will be destroyed by ncreel_destroy(); this transfers ownership."],["ncreel_del","Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the tablet cannot be found."],["ncreel_destroy","Destroy an ncreel allocated with ncreel_create()."],["ncreel_focused","Return the focused tablet, if any tablets are present. This is not a copy; be careful to use it only for the duration of a critical section."],["ncreel_next","Change focus to the next tablet, if one exists"],["ncreel_offer_input","Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the reel, false is returned. Relevant inputs include:"],["ncreel_plane","Returns the ncplane on which this ncreel lives."],["ncreel_prev","Change focus to the previous tablet, if one exists"],["ncreel_redraw","Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and tablets will be lain out, using the focused tablet as a fulcrum. Tablet drawing callbacks will be invoked for each visible tablet."],["ncreel_tabletcount","Return the number of nctablets in the ncreel 'nr'."],["ncselector_additem","Dynamically add or delete items. It is usually sufficient to supply a static list of items via ncselector_options->items."],["ncselector_create",""],["ncselector_delitem",""],["ncselector_destroy","Destroy the ncselector. If 'item' is not NULL, the last selected option will be strdup()ed and assigned to '*item' (and must be free()d by the caller)."],["ncselector_nextitem",""],["ncselector_offer_input","Offer the input to the ncselector. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the selector, false is returned. Relevant inputs include:"],["ncselector_plane","Return a reference to the ncselector's underlying ncplane."],["ncselector_previtem","Move up or down in the list. A reference to the newly-selected item is returned, or NULL if there are no items in the list."],["ncselector_selected","Return reference to the selected option, or NULL if there are no items."],["ncstrwidth","Returns the number of columns occupied by a multibyte (UTF-8) string, or -1 if a non-printable/illegal character is encountered."],["ncsubproc_createv","see exec(2). p-types use $PATH. e-type passes environment vars."],["ncsubproc_createvp",""],["ncsubproc_createvpe",""],["ncsubproc_destroy",""],["ncsubproc_plane",""],["nctablet_ncplane","Deprecated form of nctablet_plane()."],["nctablet_plane","Access the ncplane associated with nctablet 't', if one exists."],["nctablet_userptr","Returns a pointer to a user pointer associated with this nctablet."],["ncuplot_add_sample","Add to or set the value corresponding to this x. If x is beyond the current x window, the x window is advanced to include x, and values passing beyond the window are lost. The first call will place the initial window. The plot will be redrawn, but notcurses_render() is not called."],["ncuplot_create","Use the provided plane 'n' for plotting according to the options 'opts'. The plot will make free use of the entirety of the plane. For domain autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while ncdplot holds doubles."],["ncuplot_destroy",""],["ncuplot_plane","Return a reference to the ncplot's underlying ncplane."],["ncuplot_sample",""],["ncuplot_set_sample",""],["ncvisual_at_yx","Get the specified pixel from the specified ncvisual."],["ncvisual_decode","extract the next frame from an ncvisual. returns 1 on end of file, 0 on success, and -1 on failure."],["ncvisual_decode_loop","decode the next frame ala ncvisual_decode(), but if we have reached the end, rewind to the first frame of the ncvisual. a subsequent 'ncvisual_render()' will render the first frame, as if the ncvisual had been closed and reopened. the return values remain the same as those of ncvisual_decode()."],["ncvisual_destroy","Destroy an ncvisual. Rendered elements will not be disrupted, but the visual can be neither decoded nor rendered any further."],["ncvisual_from_bgra","ncvisual_from_rgba(), but 'bgra' is arranged as BGRA."],["ncvisual_from_file","Open a visual at 'file', extract a codec and parameters, decode the first image to memory."],["ncvisual_from_plane","Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces, half blocks, and full blocks. The latter will be checked, and any other glyph will result in a NULL being returned. This function exists so that planes can be subjected to ncvisual transformations. If possible, it's better to create the ncvisual from memory using ncvisual_from_rgba()."],["ncvisual_from_rgba","Prepare an ncvisual, and its underlying plane, based off RGBA content in memory at 'rgba'. 'rgba' must be a flat array of 32-bit 8bpc RGBA pixels. These must be arranged in 'rowstride' lines, where the first 'cols' * 4b are actual data. There must be 'rows' lines. The total size of 'rgba' must thus be at least (rows * rowstride) bytes, of which (rows * cols * 4) bytes are actual data. Resulting planes are ceil('rows' / 2) x 'cols'."],["ncvisual_geom","Get the size and ratio of ncvisual pixels to output cells along the y ('toy') and x ('tox') axes. A ncvisual of '*y'X'*x' pixels will require ('*y' * '*toy')X('x' * 'tox') cells for full output. Returns non-zero for an invalid 'vopts->blitter'. Scaling is taken into consideration."],["ncvisual_polyfill_yx","Polyfill at the specified location within the ncvisual 'n', using 'rgba'."],["ncvisual_render","Render the decoded frame to the specified ncplane (if one is not provided, one will be created, having the exact size necessary to display the visual. In this case, 'style' must be NCSTYLE_NONE). A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and 'leny'. Negative values for 'begy' or 'begx' are an error. It is an error to specify any region beyond the boundaries of the frame. Returns the plane to which we drew (if ncv->n is NULL, a new plane will be created)."],["ncvisual_resize","Resize the visual so that it is 'rows' X 'columns'. This is a lossy transformation, unless the size is unchanged."],["ncvisual_rotate","Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are supported at the moment, but this will change FIXME."],["ncvisual_set_yx","Set the specified pixel in the specified ncvisual."],["ncvisual_simple_streamer","Shut up and display my frames! Provide as an argument to ncvisual_stream(). If you'd like subtitles to be decoded, provide an ncplane as the curry. If the curry is NULL, subtitles will not be displayed."],["ncvisual_stream","Stream the entirety of the media, according to its own timing. Blocking, obviously. streamer may be NULL; it is otherwise called for each frame, and its return value handled as outlined for streamcb. If streamer() returns non-zero, the stream is aborted, and that value is returned. By convention, return a positive number to indicate intentional abort from within streamer(). 'timescale' allows the frame duration time to be scaled. For a visual naturally running at 30FPS, a 'timescale' of 0.1 will result in 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to supply 'timescale' less than or equal to 0."],["ncvisual_subtitle","If a subtitle ought be displayed at this time, return a heap-allocated copy of the UTF8 text."],["notcurses_at_yx","Retrieve the contents of the specified cell as last rendered. Returns the EGC or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["notcurses_bottom","Return the bottommost ncplane, of which there is always at least one."],["notcurses_canchangecolor","Can we set the \"hardware\" palette? Requires the \"ccc\" terminfo capability."],["notcurses_canfade","Can we fade? Fading requires either the \"rgb\" or \"ccc\" terminfo capability."],["notcurses_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["notcurses_canopen_videos","Can we load videos? This requires being built against FFmpeg."],["notcurses_cansixel","Can we blit to Sixel?"],["notcurses_cantruecolor","Can we directly specify RGB values per cell, or only use palettes?"],["notcurses_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["notcurses_cursor_disable",""],["notcurses_cursor_enable","Enable or disable the terminal's cursor, if supported, placing it at 'y', 'x'. Immediate effect (no need for a call to notcurses_render()). It is an error if 'y', 'x' lies outside the standard plane."],["notcurses_debug","Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform, and subject to change. It includes geometry of all planes, from all piles."],["notcurses_drop_planes","Destroy all ncplanes other than the stdplane."],["notcurses_getc","See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking operation, and otherwise a timespec to bound blocking. Signals in sigmask (less several we handle internally) will be atomically masked and unmasked per ppoll(2). It should generally contain all signals. Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the return value is the 'id' field from that event. 'ni' may be NULL."],["notcurses_init","Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in which case /dev/tty will be opened. Returns NULL on error, including any failure initializing terminfo."],["notcurses_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call notcurses_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["notcurses_lex_blitter","Lex a blitter."],["notcurses_lex_margins","Lex a margin argument according to the standard Notcurses definition. There can be either a single number, which will define all margins equally, or there can be four numbers separated by commas."],["notcurses_lex_scalemode","Lex a visual scaling mode (one of \"none\", \"stretch\", or \"scale\")."],["notcurses_mouse_disable","Disable mouse events. Any events in the input queue can still be delivered."],["notcurses_mouse_enable","Enable the mouse in \"button-event tracking\" mode with focus detection and UTF8-style extended coordinates. On failure, -1 is returned. On success, 0 is returned, and mouse events will be published to notcurses_getc()."],["notcurses_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["notcurses_refresh","Refresh the physical screen to match what was last rendered (i.e., without reflecting any changes since the last call to notcurses_render()). This is primarily useful if the screen is externally corrupted, or if an NCKEY_RESIZE event has been read and you're not yet ready to render."],["notcurses_render","Renders and rasterizes the standard pile in one shot. Blocking call."],["notcurses_render_to_buffer","Perform the rendering and rasterization portion of notcurses_render(), but do not write the resulting buffer out to the terminal. Using this function, the user can control the writeout process, and render a second frame while writing another. The returned buffer must be freed by the caller."],["notcurses_render_to_file","Write the last rendered frame, in its entirety, to 'fp'. If notcurses_render() has not yet been called, nothing will be written."],["notcurses_stats","Acquire an atomic snapshot of the Notcurses object's stats."],["notcurses_stats_alloc","Allocate an ncstats object. Use this rather than allocating your own, since future versions of Notcurses might enlarge this structure."],["notcurses_stats_reset","Reset all cumulative stats (immediate ones, such as fbbytes, are not reset)."],["notcurses_stdplane","Get a reference to the standard plane (one matching our current idea of the terminal size) for this terminal. The standard plane always exists, and its origin is always at the uppermost, leftmost cell of the terminal."],["notcurses_stdplane_const",""],["notcurses_stop","Destroy a Notcurses context."],["notcurses_str_blitter","Get the name of a blitter."],["notcurses_str_scalemode","Get the name of a scaling mode."],["notcurses_supported_styles","Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only indicated as supported if the terminal can support it together with color. For more information, see the \"ncv\" capability in terminfo(5)."],["notcurses_top","Return the topmost ncplane, of which there is always at least one."],["notcurses_ucs32_to_utf8","input functions like notcurses_getc() return ucs32-encoded char32_t. convert a series of char32_t to utf8. result must be at least 4 bytes per input char32_t (6 bytes per char32_t will future-proof against Unicode expansion). the number of bytes used is returned, or -1 if passed illegal ucs32, or too small of a buffer."],["notcurses_version","Get a human-readable string describing the running Notcurses version."],["notcurses_version_components","Cannot be inline, as we want to get the versions of the actual Notcurses library we loaded, not what we compile against."],["nrand48",""],["ntohl","Functions to convert between host and network byte order."],["ntohs",""],["palette256_free","Free the palette store 'p'."],["palette256_new","Create a new palette store. It will be initialized with notcurses' best knowledge of the currently configured palette. The palette upon startup cannot be reliably detected, sadly."],["palette256_use","Attempt to configure the terminal with the provided palette 'p'. Does not transfer ownership of 'p'; palette256_free() can (ought) still be called."],["pclose","Close a stream opened by popen and return the status of its child."],["perror","Print a message describing the meaning of the value of errno."],["popen","Create a new stream connected to a pipe running the given command."],["printf","Write formatted output to stdout."],["putc",""],["putchar","Write a character to stdout."],["putenv","The SVID says this is in <stdio.h>, but this seems a better place.\t*/ If there is no `=', remove NAME from the environment."],["puts","Write a string, followed by a newline, to stdout."],["putw","Write a word (int) to STREAM."],["putwc",""],["putwchar","Write a character to stdout."],["qsort","Sort NMEMB elements of BASE, of SIZE bytes each, using COMPAR to perform the comparisons."],["quick_exit","Call all functions registered with `at_quick_exit' in the reverse of the order in which they were registered and terminate program execution with STATUS."],["raise","Raise signal SIG, i.e., send SIG to yourself."],["rand","Return a random integer between 0 and RAND_MAX inclusive."],["realloc","Re-allocate the previously allocated block in PTR, making the new block SIZE bytes long.  */ the same pointer that was passed to it, aliasing needs to be allowed between objects pointed by the old and new pointers."],["recv","Read N bytes into BUF from socket FD. Returns the number read or -1 for errors."],["recvfrom","Read N bytes into BUF through socket FD. If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of the sender, and store the actual size of the address in *ADDR_LEN. Returns the number of bytes read or -1 for errors."],["recvmsg","Receive a message as described by MESSAGE from socket FD. Returns the number of bytes read or -1 for errors."],["remove","Remove file FILENAME."],["rename","Rename file OLD to NEW."],["rewind","Rewind to the beginning of STREAM."],["scanf","Read formatted input from stdin."],["scanf1","Read formatted input from stdin."],["seed48",""],["send","Send N bytes of BUF to socket FD.  Returns the number sent or -1."],["sendmsg","Send a message described MESSAGE on socket FD. Returns the number of bytes sent, or -1 for errors."],["sendto","Send N bytes of BUF on socket FD to peer at address ADDR (which is ADDR_LEN bytes long).  Returns the number sent, or -1 for errors."],["setbuf","If BUF is NULL, make STREAM unbuffered. Else make it use buffer BUF, of size BUFSIZ."],["setsockopt","Set socket FD's option OPTNAME at protocol level LEVEL to *OPTVAL (which is OPTLEN bytes long). Returns 0 on success, -1 for errors."],["setvbuf","Make STREAM use buffering mode MODE. If BUF is not NULL, use N bytes of it for buffering; else allocate an internal buffer N bytes long."],["shutdown","Shut down all or part of the connection open on socket FD. HOW determines what to shut down: SHUT_RD   = No more receptions; SHUT_WR   = No more transmissions; SHUT_RDWR = No more receptions or transmissions. Returns 0 on success, -1 for errors."],["sigaction","Get and/or set the action for signal SIG."],["sigaddset","Add SIGNO to SET."],["sigdelset","Remove SIGNO from SET."],["sigemptyset","Clear all signals from SET."],["sigfillset","Set all signals in SET."],["sigismember","Return 1 if SIGNO is in SET, 0 if not."],["sigpending","Put in SET all signals that are blocked and waiting to be delivered."],["sigprocmask","Get and/or change the set of blocked signals."],["sigsuspend","Change the set of blocked signals to SET, wait until a signal arrives, and restore the set of blocked signals."],["snprintf","Maximum chars of output to write in MAXLEN."],["socket","Create a new socket of type TYPE in domain DOMAIN, using protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically. Returns a file descriptor for the new socket, or -1 for errors."],["socketpair","Create two new sockets, of type TYPE in domain DOMAIN and using protocol PROTOCOL, which are connected to each other, and put file descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero, one will be chosen automatically.  Returns 0 on success, -1 for errors."],["sprintf","Write formatted output to S."],["srand","Seed the random number generator with the given number."],["srand48","Seed random number generator."],["sscanf","Read formatted input from S."],["sscanf1","Read formatted input from S."],["strcat","Append SRC onto DEST."],["strchr",""],["strcmp","Compare S1 and S2."],["strcoll","Compare the collated forms of S1 and S2."],["strcpy","Copy SRC to DEST."],["strcspn","Return the length of the initial segment of S which consists entirely of characters not in REJECT."],["strerror","Return a string describing the meaning of the `errno' code in ERRNUM."],["strftime","Format TP into S according to FORMAT. Write no more than MAXSIZE characters and return the number of characters written, or 0 if it would exceed MAXSIZE."],["strlen","Return the length of S."],["strncat","Append no more than N characters from SRC onto DEST."],["strncmp","Compare N characters of S1 and S2."],["strncpy","Copy no more than N characters of SRC to DEST."],["strpbrk",""],["strptime","Parse S according to FORMAT and store binary time information in TP. The return value is a pointer to the first unparsed character in S."],["strrchr",""],["strspn","Return the length of the initial segment of S which consists entirely of characters in ACCEPT."],["strstr",""],["strtod","Convert a string to a floating-point number."],["strtof","Likewise for `float' and `long double' sizes of floating-point numbers."],["strtok","Divide S into tokens separated by characters in DELIM."],["strtok_r",""],["strtol","Convert a string to a long integer."],["strtoll","Convert a string to a quadword integer."],["strtoul","Convert a string to an unsigned long integer."],["strtoull","Convert a string to an unsigned quadword integer."],["strxfrm","Put a transformation of SRC into no more than N bytes of DEST."],["swprintf","Write formatted output of at most N characters to S."],["swscanf","Read formatted input from S."],["swscanf1","Read formatted input from S."],["system","Execute the given line as a shell command."],["tempnam","Generate a unique temporary filename using up to five characters of PFX if it is not NULL.  The directory to put this file in is searched for as follows: First the environment variable \"TMPDIR\" is checked. If it contains the name of a writable directory, that directory is used. If not and if DIR is not NULL, that value is checked.  If that fails, P_tmpdir is tried and finally \"/tmp\".  The storage for the filename is allocated by `malloc'."],["time","Return the current time and put it in *TIMER if TIMER is not NULL."],["timespec_get","Set TS to calendar time based in time base BASE."],["tmpfile",""],["tmpnam","Generate a temporary filename."],["toascii","Return the part of C that is in the ASCII set (i.e., the low-order 7 bits of C)."],["tolower","Return the lowercase version of C."],["toupper","Return the uppercase version of C."],["towlower","Converts an uppercase letter to the corresponding lowercase letter."],["towupper","Converts an lowercase letter to the corresponding uppercase letter."],["tzset","Set time conversion information from the TZ environment variable. If TZ is not defined, a locale-dependent default is used."],["ungetc","Push a character back onto the input buffer of STREAM."],["ungetwc","Push a character back onto the input buffer of STREAM."],["vfprintf","Write formatted output to S from argument list ARG."],["vfscanf","Read formatted input from S into argument list ARG."],["vfscanf1","Read formatted input from S into argument list ARG."],["vfwprintf","Write formatted output to S from argument list ARG."],["vfwscanf","Read formatted input from S into argument list ARG."],["vprintf","Write formatted output to stdout from argument list ARG."],["vscanf","Read formatted input from stdin into argument list ARG."],["vscanf1","Read formatted input from stdin into argument list ARG."],["vsnprintf",""],["vsprintf","Write formatted output to S from argument list ARG."],["vsscanf","Read formatted input from S into argument list ARG."],["vsscanf1","Read formatted input from S into argument list ARG."],["vswprintf","Write formatted output of at most N character to S from argument list ARG."],["vswscanf","Read formatted input from S into argument list ARG."],["vwprintf","Write formatted output to stdout from argument list ARG."],["vwscanf","Read formatted input from stdin into argument list ARG."],["wcrtomb","Write multibyte representation of wide character WC to S."],["wcscat","Append SRC onto DEST."],["wcschr",""],["wcscmp","Compare S1 and S2."],["wcscoll","Compare S1 and S2, both interpreted as appropriate to the LC_COLLATE category of the current locale."],["wcscpy","Copy SRC to DEST."],["wcscspn","Return the length of the initial segmet of WCS which consists entirely of wide characters not in REJECT."],["wcsftime","Format TP into S according to FORMAT. Write no more than MAXSIZE wide characters and return the number of wide characters written, or 0 if it would exceed MAXSIZE."],["wcslen","Return the number of wide characters in S."],["wcsncat","Append no more than N wide-characters of SRC onto DEST."],["wcsncmp","Compare N wide-characters of S1 and S2."],["wcsncpy","Copy no more than N wide-characters of SRC to DEST."],["wcspbrk",""],["wcsrchr",""],["wcsrtombs","Write multibyte character representation of wide character string SRC to DST."],["wcsspn","Return the length of the initial segmet of WCS which consists entirely of wide characters in  ACCEPT."],["wcsstr",""],["wcstod","Convert initial portion of the wide string NPTR to `double' representation."],["wcstof","Likewise for `float' and `long double' sizes of floating-point numbers."],["wcstok","Divide WCS into tokens separated by characters in DELIM."],["wcstol","Convert initial portion of wide string NPTR to `long int' representation."],["wcstoll","Convert initial portion of wide string NPTR to `long long int' representation."],["wcstombs","Convert a wide char string to multibyte string."],["wcstoul","Convert initial portion of wide string NPTR to `unsigned long int' representation."],["wcstoull","Convert initial portion of wide string NPTR to `unsigned long long int' representation."],["wcswcs",""],["wcswidth","Determine number of column positions required for first N wide characters (or fewer if S ends before this) in S."],["wcsxfrm","Transform S2 into array pointed to by S1 such that if wcscmp is applied to two transformed strings the result is the as applying `wcscoll' to the original strings."],["wctob","Determine whether C corresponds to a member of the extended character set whose multibyte representation is a single byte."],["wctomb","Put the multibyte character represented by WCHAR in S, returning its length."],["wctype","Construct value that describes a class of wide characters identified by the string argument PROPERTY."],["wcwidth","Determine number of column positions required for C."],["wmemchr",""],["wmemcmp","Compare N wide characters of S1 and S2."],["wmemcpy","Copy N wide characters of SRC to DEST."],["wmemmove","Copy N wide characters of SRC to DEST, guaranteeing correct behavior for overlapping strings."],["wmemset","Set N wide characters of S to C."],["wprintf","Write formatted output to stdout."],["wscanf","Read formatted input from stdin."],["wscanf1","Read formatted input from stdin."]],"static":[["__daylight",""],["__timezone",""],["__tzname",""],["daylight",""],["in6addr_any",""],["in6addr_loopback",""],["notcurses_blitters",""],["optarg",""],["opterr",""],["optind",""],["optopt",""],["stderr",""],["stdin",""],["stdout",""],["timezone",""],["tzname",""]],"struct":[["_G_fpos64_t","The tag name of this struct is _G_fpos64_t to preserve historic C++ mangled names for functions taking fpos_t and/or fpos64_t arguments.  That name should not be used in new code."],["_G_fpos_t","The tag name of this struct is _G_fpos_t to preserve historic C++ mangled names for functions taking fpos_t arguments. That name should not be used in new code."],["_IO_FILE","The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code."],["_IO_codecvt",""],["_IO_marker",""],["_IO_wide_data",""],["__IncompleteArrayField",""],["__fsid_t",""],["__mbstate_t","Conversion state information."],["__sigset_t",""],["__va_list_tag",""],["blitset","a system for rendering RGBA pixels as text glyphs"],["cmsghdr","Structure used for storage of ancillary data object information."],["div_t","Returned by `div'."],["in6_addr","IPv6 address"],["in_addr",""],["iovec","Structure for scatter/gather I/O."],["ipv6_mreq","Likewise, for IPv6."],["ldiv_t",""],["linger","Structure used to manipulate the SO_LINGER option."],["lldiv_t","Returned by `lldiv'."],["msghdr","Structure describing messages sent by `sendmsg' and received by `recvmsg'."],["nccell","An nccell corresponds to a single character cell on some plane, which can be occupied by a single grapheme cluster (some root spacing glyph, along with possible combining characters, which might span multiple columns). At any cell, we can have a theoretically arbitrarily long UTF-8 string, a foreground color, a background color, and an attribute set. Valid grapheme cluster contents include:"],["ncdirect",""],["ncdplot",""],["ncfadectx",""],["ncfdplane",""],["ncfdplane_options","read from an fd until EOF (or beyond, if follow is set), invoking the user's callback each time. runs in its own context. on EOF or error, the finalizer callback will be invoked, and the user ought destroy the ncfdplane. the data is not guaranteed to be nul-terminated, and may contain arbitrary zeroes."],["ncinput","An input event. Cell coordinates are currently defined only for mouse events."],["ncmenu",""],["ncmenu_item","Menus. Horizontal menu bars are supported, on the top and/or bottom rows. If the menu bar is longer than the screen, it will be only partially visible. Menus may be either visible or invisible by default. In the event of a screen resize, menus will be automatically moved/resized. Elements can be dynamically enabled or disabled at all levels (menu, section, and item),"],["ncmenu_options",""],["ncmenu_section",""],["ncmselector_item",""],["ncmultiselector",""],["ncmultiselector_options","multiselection widget -- a selector supporting multiple selections."],["ncplane",""],["ncplane_options",""],["ncplot_options",""],["ncprogbar",""],["ncprogbar_options",""],["ncreader",""],["ncreader_options",""],["ncreel",""],["ncreel_options",""],["ncselector",""],["ncselector_item","selection widget -- an ncplane with a title header and a body section. the body section supports infinite scrolling up and down."],["ncselector_options",""],["ncstats",""],["ncsubproc",""],["ncsubproc_options",""],["nctablet",""],["ncuplot",""],["ncvisual",""],["ncvisual_options",""],["notcurses",""],["notcurses_options","Configuration for notcurses_init()."],["palette256","Palette API. Some terminals only support 256 colors, but allow the full palette to be specified with arbitrary RGB colors. In all cases, it's more performant to use indexed colors, since it's much less data to write to the terminal. If you can limit yourself to 256 colors, that's probably best."],["sigaction","Structure describing the action to be taken when a signal arrives."],["sockaddr","Structure describing a generic socket address."],["sockaddr_in","Structure describing an Internet socket address."],["sockaddr_in6","Ditto, for IPv6."],["sockaddr_storage",""],["timespec","POSIX.1b structure for a time value.  This is like a `struct timeval' but has nanoseconds instead of microseconds."],["tm","ISO C `broken-down time' structure."]],"type":[["FILE","The opaque type of streams.  This is the definition used elsewhere."],["_Float32",""],["_Float32x",""],["_Float64",""],["_Float64x",""],["_IO_lock_t",""],["__FILE",""],["__blkcnt64_t",""],["__blkcnt_t",""],["__blksize_t",""],["__builtin_va_list",""],["__caddr_t",""],["__clock_t",""],["__clockid_t",""],["__compar_fn_t",""],["__daddr_t",""],["__dev_t",""],["__fpos64_t","The tag name of this struct is _G_fpos64_t to preserve historic C++ mangled names for functions taking fpos_t and/or fpos64_t arguments.  That name should not be used in new code."],["__fpos_t","The tag name of this struct is _G_fpos_t to preserve historic C++ mangled names for functions taking fpos_t arguments. That name should not be used in new code."],["__fsblkcnt64_t",""],["__fsblkcnt_t",""],["__fsfilcnt64_t",""],["__fsfilcnt_t",""],["__fsword_t",""],["__gid_t",""],["__gnuc_va_list",""],["__id_t",""],["__ino64_t",""],["__ino_t",""],["__int16_t",""],["__int32_t",""],["__int64_t",""],["__int8_t","Fixed-size types, underlying types depend on word size and compiler."],["__int_least16_t",""],["__int_least32_t",""],["__int_least64_t",""],["__int_least8_t","Smallest types with at least a given width."],["__intmax_t",""],["__intptr_t",""],["__key_t",""],["__loff_t","These few don't really vary by system, they always correspond to one of the other defined types."],["__mode_t",""],["__nlink_t",""],["__off64_t",""],["__off_t",""],["__pid_t",""],["__quad_t",""],["__rlim64_t",""],["__rlim_t",""],["__sig_atomic_t","C99: An integer type that can be accessed as an atomic entity, even in the presence of asynchronous interrupts. It is not currently necessary for this to be machine-specific."],["__sighandler_t","Type of a signal handler."],["__socket_type","Types of sockets."],["__socklen_t",""],["__ssize_t",""],["__suseconds_t",""],["__syscall_slong_t",""],["__syscall_ulong_t",""],["__time_t",""],["__timer_t",""],["__u_char","Convenience types."],["__u_int",""],["__u_long",""],["__u_quad_t",""],["__u_short",""],["__uid_t",""],["__uint16_t",""],["__uint32_t",""],["__uint64_t",""],["__uint8_t",""],["__uint_least16_t",""],["__uint_least32_t",""],["__uint_least64_t",""],["__uint_least8_t",""],["__uintmax_t",""],["__useconds_t",""],["_bindgen_ty_1",""],["_bindgen_ty_2",""],["_bindgen_ty_3","Bits in the FLAGS argument to `send', `recv', et al."],["_bindgen_ty_4","Socket level message types.  This must match the definitions in <linux/socket.h>."],["_bindgen_ty_5","The following constants should be used for the second parameter of `shutdown'."],["_bindgen_ty_6","Standard well-defined IP protocols."],["_bindgen_ty_7",""],["_bindgen_ty_8","Standard well-known ports."],["blkcnt_t",""],["cell",""],["char16_t","Define the 16-bit and 32-bit character types."],["char32_t",""],["clock_t","Returned by `clock'."],["clockid_t","Clock ID used in clock and timer functions."],["dev_t",""],["fadecb","Called for each fade iteration on 'ncp'. If anything but 0 is returned, the fading operation ceases immediately, and that value is propagated out. The recommended absolute display time target is passed in 'tspec'."],["fpos_t",""],["fsblkcnt_t",""],["fsfilcnt_t",""],["gid_t",""],["id_t",""],["in_addr_t","Internet address."],["in_port_t","Type to represent a port."],["ino_t",""],["int_fast16_t",""],["int_fast32_t",""],["int_fast64_t",""],["int_fast8_t","Signed."],["int_least16_t",""],["int_least32_t",""],["int_least64_t",""],["int_least8_t","Signed."],["intmax_t","Largest integral types."],["key_t",""],["mbstate_t",""],["mode_t",""],["ncalign_e","Alignment within a plane or terminal. Left/right-justified, or centered."],["ncblitter_e","we never blit full blocks, but instead spaces (more efficient) with the background set to the desired foreground."],["ncfdplane_callback",""],["ncfdplane_done_cb",""],["ncloglevel_e","These log levels consciously map cleanly to those of libav; Notcurses itself does not use this full granularity. The log level does not affect the opening and closing banners, which can be disabled via the notcurses_option struct's 'suppress_banner'. Note that if stderr is connected to the same terminal on which we're rendering, any kind of logging will disrupt the output."],["ncscale_e","How to scale an ncvisual during rendering. NCSCALE_NONE will apply no scaling. NCSCALE_SCALE scales a visual to the plane's size, maintaining aspect ratio. NCSCALE_STRETCH stretches and scales the image in an attempt to fill the entirety of the plane."],["nlink_t",""],["off_t",""],["pid_t",""],["register_t",""],["sa_family_t","POSIX.1g specifies this type name for the `sa_family' member."],["sig_atomic_t","An integral type that can be modified atomically, without the possibility of a signal arriving in the middle of the operation."],["sigset_t","A set of signals to be blocked, unblocked, or waited for."],["size_t",""],["socklen_t",""],["ssize_t",""],["streamcb","Called for each frame rendered from 'ncv'. If anything but 0 is returned, the streaming operation ceases immediately, and that value is propagated out. The recommended absolute display time target is passed in 'tspec'."],["suseconds_t",""],["tabletcb","Tablet draw callback, provided a tablet (from which the ncplane and userptr may be extracted), and a bool indicating whether output ought be drawn from the top (true) or bottom (false). Returns non-negative count of output lines, which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."],["time_t","Returned by `time'."],["timer_t","Timer ID returned by `timer_create'."],["u_int16_t",""],["u_int32_t",""],["u_int64_t",""],["u_int8_t","These were defined by ISO C without the first `_'."],["uid_t",""],["uint_fast16_t",""],["uint_fast32_t",""],["uint_fast64_t",""],["uint_fast8_t","Unsigned."],["uint_least16_t",""],["uint_least32_t",""],["uint_least64_t",""],["uint_least8_t","Unsigned."],["uintmax_t",""],["useconds_t",""],["va_list",""],["wchar_t",""],["wctype_t","Scalar type that can hold values which represent locale-specific character classifications."],["wint_t",""]],"union":[["__mbstate_t__bindgen_ty_1",""],["in6_addr__bindgen_ty_1",""]]});