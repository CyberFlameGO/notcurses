initSidebarItems({"constant":[["NCALIGN_CENTER","Center alignment within an [`NcPlane`] or terminal."],["NCALIGN_LEFT","Left alignment within an [`NcPlane`] or terminal."],["NCALIGN_RIGHT","Right alignment within an [`NcPlane`] or terminal."],["NCALIGN_UNALIGNED","Do not align an [`NcPlane`] or terminal."],["NCBLIT_1x1","[`NcBlitter`] mode using: space, compatible with ASCII"],["NCBLIT_2x1","[`NcBlitter`] mode using: halves + 1x1 (space) ‚ñÑ‚ñÄ"],["NCBLIT_2x2","[`NcBlitter`] mode using: quadrants + 2x1 ‚ñó‚ñê ‚ññ‚ñÄ‚ñü‚ñå‚ñô"],["NCBLIT_3x2","[`NcBlitter`] mode using: sextants ü¨Äü¨Åü¨Çü¨Éü¨Ñü¨Öü¨Üü¨áü¨àü¨âü¨äü¨ãü¨åü¨çü¨éü¨èü¨êü¨ëü¨íü¨ìü¨îü¨ïü¨ñü¨óü¨òü¨ôü¨öü¨õü¨úü¨ùü¨ûü¨üü¨†ü¨°ü¨¢ü¨£ü¨§ü¨•ü¨¶ü¨ßü¨®ü¨©ü¨™ü¨´ü¨¨ü¨≠ü¨Æü¨Øü¨∞ü¨±ü¨≤ü¨≥ü¨¥ü¨µü¨∂ü¨∑ü¨∏ü¨πü¨∫ü¨ª"],["NCBLIT_4x1","[`NcBlitter`] mode using: four vertical levels ‚ñà‚ñÜ‚ñÑ‚ñÇ"],["NCBLIT_8x1","[`NcBlitter`] mode using: eight vertical levels ‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ"],["NCBLIT_BRAILLE","[`NcBlitter`] mode using: 4 rows, 2 cols (braille) ‚°Ä‚°Ñ‚°Ü‚°á‚¢Ä‚£Ä‚£Ñ‚£Ü‚£á‚¢†‚£†‚£§‚£¶‚£ß‚¢∞‚£∞‚£¥‚£∂‚£∑‚¢∏‚£∏‚£º‚£æ‚£ø"],["NCBLIT_DEFAULT","[`NcBlitter`] mode where the blitter is automatically chosen"],["NCBLIT_SIXEL","[`NcBlitter`] mode (not yet implemented)"],["NCBOXCORNER_MASK",""],["NCBOXCORNER_SHIFT",""],["NCBOXGRAD_BOTTOM",""],["NCBOXGRAD_LEFT",""],["NCBOXGRAD_RIGHT",""],["NCBOXGRAD_TOP",""],["NCBOXMASK_BOTTOM",""],["NCBOXMASK_LEFT",""],["NCBOXMASK_RIGHT",""],["NCBOXMASK_TOP",""],["NCCELL_ALPHA_BLEND","[`NcAlphaBits`] bits indicating [`NcCell`]'s foreground or background color will be a composite between its color and the `NcCell`s' corresponding colors underneath it"],["NCCELL_ALPHA_HIGHCONTRAST","[`NcAlphaBits`] bits indicating [`NcCell`]'s foreground color will be high-contrast (relative to the computed background). Background cannot be highcontrast"],["NCCELL_ALPHA_OPAQUE","[`NcAlphaBits`] bits indicating [`NcCell`]'s foreground or background color is used unchanged"],["NCCELL_ALPHA_TRANSPARENT","[`NcAlphaBits`] bits indicating [`NcCell`]'s foreground or background color is derived entirely from the `NcCell`s underneath it"],["NCCELL_BGDEFAULT_MASK","If this bit is set, we are not using the default background color"],["NCCELL_BG_ALPHA_MASK","Extract these bits to get the background alpha mask ([`NcAlphaBits`])"],["NCCELL_BG_PALETTE","If this bit and [`NCCELL_BGDEFAULT_MASK`] are set, we're using a palette-indexed background color"],["NCCELL_BG_RGB_MASK","Extract these bits to get the background [`NcRgb`][crate::NcRgb] value"],["NCCELL_FGDEFAULT_MASK","If this bit is set, we are not using the default foreground color"],["NCCELL_FG_ALPHA_MASK","Extract these bits to get the foreground alpha mask ([`NcAlphaBits`])"],["NCCELL_FG_PALETTE","If this bit and [`NCCELL_FGDEFAULT_MASK`] are set, we're using a palette-indexed background color"],["NCCELL_FG_RGB_MASK","Extract these bits to get the foreground [`NcRgb`][crate::NcRgb] value"],["NCCELL_NOBACKGROUND_MASK","Indicates the glyph is entirely foreground"],["NCCELL_WIDEASIAN_MASK","If this bit is set, the cell is part of a multicolumn glyph."],["NCCHANNEL_ALPHA_MASK","Extract these bits to get a channel's alpha value"],["NCDIRECT_OPTION_INHIBIT_CBREAK","Flag that avoids placing the terminal into cbreak mode (disabling echo and line buffering)"],["NCDIRECT_OPTION_INHIBIT_SETLOCALE","Flag that avoids calling setlocale(LC_ALL, NULL)"],["NCKEY_BACKSPACE","backspace (sometimes)"],["NCKEY_BEGIN",""],["NCKEY_BUTTON1",""],["NCKEY_BUTTON10",""],["NCKEY_BUTTON11",""],["NCKEY_BUTTON2",""],["NCKEY_BUTTON3",""],["NCKEY_BUTTON4","scrollwheel up"],["NCKEY_BUTTON5","scrollwheel down"],["NCKEY_BUTTON6",""],["NCKEY_BUTTON7",""],["NCKEY_BUTTON8",""],["NCKEY_BUTTON9",""],["NCKEY_CANCEL",""],["NCKEY_CENTER","the most truly neutral of keypresses"],["NCKEY_CLOSE",""],["NCKEY_CLS","\"clear-screen or erase\""],["NCKEY_COMMAND",""],["NCKEY_COPY",""],["NCKEY_DEL",""],["NCKEY_DLEFT","down + left on keypad"],["NCKEY_DOWN",""],["NCKEY_DRIGHT",""],["NCKEY_END",""],["NCKEY_ENTER",""],["NCKEY_EXIT",""],["NCKEY_F00",""],["NCKEY_F01",""],["NCKEY_F02",""],["NCKEY_F03",""],["NCKEY_F04",""],["NCKEY_F05",""],["NCKEY_F06",""],["NCKEY_F07",""],["NCKEY_F08",""],["NCKEY_F09",""],["NCKEY_F10",""],["NCKEY_F11",""],["NCKEY_F12",""],["NCKEY_F13",""],["NCKEY_F14",""],["NCKEY_F15",""],["NCKEY_F16",""],["NCKEY_F17",""],["NCKEY_F18",""],["NCKEY_F19",""],["NCKEY_F20",""],["NCKEY_F21",""],["NCKEY_F22",""],["NCKEY_F23",""],["NCKEY_F24",""],["NCKEY_F25",""],["NCKEY_F26",""],["NCKEY_F27",""],["NCKEY_F28",""],["NCKEY_F29",""],["NCKEY_F30",""],["NCKEY_F31",""],["NCKEY_F32",""],["NCKEY_F33",""],["NCKEY_F34",""],["NCKEY_F35",""],["NCKEY_F36",""],["NCKEY_F37",""],["NCKEY_F38",""],["NCKEY_F39",""],["NCKEY_F40",""],["NCKEY_F41",""],["NCKEY_F42",""],["NCKEY_F43",""],["NCKEY_F44",""],["NCKEY_F45",""],["NCKEY_F46",""],["NCKEY_F47",""],["NCKEY_F48",""],["NCKEY_F49",""],["NCKEY_F50",""],["NCKEY_F51",""],["NCKEY_F52",""],["NCKEY_F53",""],["NCKEY_F54",""],["NCKEY_F55",""],["NCKEY_F56",""],["NCKEY_F57",""],["NCKEY_F58",""],["NCKEY_F59",""],["NCKEY_F60",""],["NCKEY_HOME",""],["NCKEY_INS",""],["NCKEY_INVALID",""],["NCKEY_LEFT",""],["NCKEY_PGDOWN",""],["NCKEY_PGUP",""],["NCKEY_PRINT",""],["NCKEY_REFRESH",""],["NCKEY_RELEASE",""],["NCKEY_RESIZE","generated interally in response to SIGWINCH"],["NCKEY_RETURN",""],["NCKEY_RIGHT",""],["NCKEY_SCROLL_DOWN",""],["NCKEY_SCROLL_UP",""],["NCKEY_ULEFT","up + left on keypad"],["NCKEY_UP",""],["NCKEY_URIGHT",""],["NCLOGLEVEL_DEBUG","this is honestly a bit much"],["NCLOGLEVEL_ERROR","we can't keep doin' this, but we can do other things"],["NCLOGLEVEL_FATAL","we're hanging around, but we've had a horrible fault"],["NCLOGLEVEL_INFO","\"detailed information"],["NCLOGLEVEL_PANIC","print diagnostics immediately related to crashing"],["NCLOGLEVEL_SILENT","default. print nothing once fullscreen service begins"],["NCLOGLEVEL_TRACE","there's probably a better way to do what you want"],["NCLOGLEVEL_VERBOSE","\"detailed information"],["NCLOGLEVEL_WARNING","you probably don't want what's happening to happen"],["NCMENU_OPTION_BOTTOM","Bottom row (as opposed to top row)"],["NCMENU_OPTION_HIDING","Hide the menu when not unrolled"],["NCMETRIC_BPREFIXCOLUMNS",""],["NCMETRIC_BPREFIXSTRLEN",""],["NCMETRIC_IPREFIXCOLUMNS",""],["NCMETRIC_IPREFIXSTRLEN",""],["NCMETRIC_PREFIXCOLUMNS",""],["NCMETRIC_PREFIXSTRLEN",""],["NCOPTION_INHIBIT_SETLOCALE","Do not call setlocale()"],["NCOPTION_NO_ALTERNATE_SCREEN","Do not enter alternate mode."],["NCOPTION_NO_FONT_CHANGES","Do not modify the font."],["NCOPTION_NO_QUIT_SIGHANDLERS","Do not handle SIG{ING, SEGV, ABRT, QUIT}"],["NCOPTION_NO_WINCH_SIGHANDLER","Do not handle SIGWINCH"],["NCOPTION_SUPPRESS_BANNERS","Do not print banners"],["NCOPTION_VERIFY_SIXEL","Test for Sixel support"],["NCPALETTESIZE",""],["NCPLANE_OPTION_HORALIGNED","Horizontal alignment relative to the parent plane. Set alignment in 'x'."],["NCPLOT_OPTION_DETECTMAXONLY","Use domain detection only for max"],["NCPLOT_OPTION_EXPONENTIALD","Exponential dependent axis"],["NCPLOT_OPTION_LABELTICKSD","Show labels for dependent axis"],["NCPLOT_OPTION_NODEGRADE","Use domain detection only for max"],["NCPLOT_OPTION_VERTICALI","Independent axis is vertical"],["NCREADER_OPTION_CURSOR","Make the terminal cursor visible across the lifetime of the ncreader, and have the ncreader manage the cursor's placement."],["NCREADER_OPTION_HORSCROLL","Enable horizontal scrolling. Virtual lines can then grow arbitrarily long."],["NCREADER_OPTION_NOCMDKEYS","Disable all editing shortcuts. By default, emacs-style keys are available."],["NCREADER_OPTION_VERSCROLL","Enable vertical scrolling. You can then use arbitrarily many virtual lines."],["NCREEL_OPTION_CIRCULAR","is navigation circular (does moving down from the last tablet move to the first, and vice versa)? only meaningful when infinitescroll is true. if infinitescroll is false, this must be false."],["NCREEL_OPTION_INFINITESCROLL","is scrolling infinite (can one move down or up forever, or is an end reached?). if true, 'circular' specifies how to handle the special case of an incompletely-filled reel."],["NCRESULT_ERR","OK value, for the functions that return [`NcResult`]"],["NCRESULT_OK","ERROR value, for the functions that return an [`NcResult`]"],["NCSCALE_NONE","Maintain original size"],["NCSCALE_SCALE","Maintain aspect ratio"],["NCSCALE_STRETCH","Throw away aspect ratio"],["NCSTYLE_BLINK",""],["NCSTYLE_BOLD",""],["NCSTYLE_DIM",""],["NCSTYLE_INVIS",""],["NCSTYLE_ITALIC",""],["NCSTYLE_MASK",""],["NCSTYLE_NONE",""],["NCSTYLE_PROTECT",""],["NCSTYLE_REVERSE",""],["NCSTYLE_STANDOUT",""],["NCSTYLE_STRUCK",""],["NCSTYLE_UNDERLINE",""],["NCVISUAL_OPTION_BLEND","Uses [`NCCELL_ALPHA_BLEND`][crate::NCCELL_ALPHA_BLEND] with visual."],["NCVISUAL_OPTION_NODEGRADE","Fails rather than degrade."]],"fn":[["cell_bchannel","Gets the background [NcChannel] from an [NcCell]."],["cell_bg_alpha","Extracts the background [NcAlphaBits] from an [NcCell] (shifted to LSBs)."],["cell_bg_default_p","Is the background [NcChannel] of this [NcCell] using the \"default background color\"?"],["cell_bg_palindex","Gets the [NcPaletteIndex] of the background [NcChannel] of the [NcCell]."],["cell_bg_palindex_p","Is the background [NcChannel] of this [NcCell] using an [NcPaletteIndex] [indexed][NcPaletteIndex] [NcPalette][crate::NcPalette] color?"],["cell_bg_rgb","Gets the background [NcRgb] from an [NcCell] (shifted to LSBs)."],["cell_bg_rgb8","Gets the background [NcColor] RGB components of an [NcCell], and returns the [NcChannel] (which can have some extra bits set)."],["cell_double_wide_p","Does the [NcCell] contain an East Asian Wide codepoint?"],["cell_duplicate","Duplicate 'c' into 'targ'; both must be/will be bound to 'n'."],["cell_extended_gcluster","return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer can be invalidated by any further operation on the plane 'n', so...watch out!"],["cell_extract","Saves the [NcStyleMask] and the [NcChannelPair], and returns the [NcEgc], of an [NcCell]."],["cell_fchannel","Gets the foreground [NcChannel] from an [NcCell]."],["cell_fg_alpha","Extracts the foreground [NcAlphaBits] from an [NcCell] (shifted to LSBs)."],["cell_fg_default_p","Is the foreground [NcChannel] of this [NcCell] using the \"default foreground color\"?"],["cell_fg_palindex","Gets the [NcPaletteIndex] of the foreground [NcChannel] of the [NcCell]."],["cell_fg_palindex_p","Is the foreground [NcChannel] of this [NcCell] using an [NcPaletteIndex] [indexed][NcPaletteIndex] [NcPalette][crate::NcPalette] color?"],["cell_fg_rgb","Gets the foreground [NcRgb] from an [NcCell] (shifted to LSBs)."],["cell_fg_rgb8","Gets the foreground [NcColor] RGB components of an [NcCell], and returns the [NcChannel] (which can have some extra bits set)."],["cell_init","Initializes (zeroes out) an [NcCell]."],["cell_load","Breaks the UTF-8 string in 'gcluster' down, setting up the cell 'c'. Returns the number of bytes copied out of 'gcluster', or -1 on failure. The styling of the cell is left untouched, but any resources are released."],["cell_load_char","Loads a 7-bit char into the [NcCell]."],["cell_prime","Same as [cell_load], plus blasts the styling with 'style' and 'channels'."],["cell_release","Release resources held by the cell 'c'."],["cell_set_bchannel","Sets the background [NcChannel] of an [NcCell] and returns the new [NcChannelPair]."],["cell_set_bg_alpha","Sets the background [NcAlphaBits] of an [NcCell]."],["cell_set_bg_default","Indicates to use the \"default color\" for the background [NcChannel] of an [NcCell]."],["cell_set_bg_palindex","Sets an [NcCell]'s background [NcPaletteIndex]."],["cell_set_bg_rgb","Sets the background [NcRgb] of an [NcCell], and marks it as not using the default color."],["cell_set_bg_rgb8","Sets the background [NcColor] 8-bit RGB components of of the [NcCell], and marks it as not using the \"default color\"."],["cell_set_fchannel","Sets the foreground [NcChannel] of an [NcCell] and returns the new [NcChannelPair]."],["cell_set_fg_alpha","Sets the foreground [NcAlphaBits] of an [NcCell]."],["cell_set_fg_default","Indicates to use the \"default color\" for the foreground [NcChannel] of an [NcCell]."],["cell_set_fg_palindex","Sets an [NcCell]'s foreground [NcPaletteIndex]."],["cell_set_fg_rgb","Sets the foreground [NcRgb] of an [NcCell], and marks it as not using the default color."],["cell_set_fg_rgb8","Sets the foreground [NcColor] 8-bit RGB components of of the [NcCell], and marks it as not using the \"default color\"."],["cell_strdup","Copies the UTF8-encoded [NcEgc] out of the cell, whether simple or complex."],["cell_styles","Extracts the [NcStyleMask] bits from an [NcCell]."],["cell_styles_off","Removes the specified [NcStyleMask] bits from an [NcCell]'s existing spec."],["cell_styles_on","Adds the specified [NcStyleMask] bits to an [NcCell]'s existing spec., whether they're actively supported or not."],["cell_styles_set","Sets just the specified [NcStyleMask] bits for an [NcCell], whether they're actively supported or not."],["cell_wide_left_p","Is this the left half of a wide character?"],["cell_wide_right_p","Is this the right half of a wide character?"],["cellcmp","Returns true if the two cells are distinct [NcEgc]s, attributes, or channels."],["cells_double_box",""],["cells_load_box","Loads up six cells with the [NcEgc]s necessary to draw a box."],["cells_rounded_box",""],["channel_alpha","Gets the [NcAlphaBits] from an [NcChannel]."],["channel_b","Gets the blue [NcColor] from an [NcChannel]."],["channel_default_p","Is this [NcChannel] using the \"default color\" rather than RGB/palette-indexed?"],["channel_g","Gets the green [NcColor] from an [NcChannel]."],["channel_palindex_p","Is this [NcChannel] using palette-indexed color rather than RGB?"],["channel_r","Gets the red [NcColor] from an [NcChannel]."],["channel_rgb","Gets the [NcRgb] of an [NcChannel]."],["channel_rgb8","Gets the three RGB [NcColor]s from an [NcChannel], and returns it."],["channel_set","Sets the [NcRgb] of an [NcChannel], and marks it as not using the \"default color\", retaining the other bits unchanged."],["channel_set_alpha","Sets the [NcAlphaBits] of an [NcChannel]."],["channel_set_b","Sets the blue [NcColor] of an [NcChannel], and returns it."],["channel_set_default","Marks an [NcChannel] as using its \"default color\", which also marks it opaque."],["channel_set_g","Sets the green [NcColor] of an [NcChannel], and returns it."],["channel_set_r","Sets the red [NcColor] of an [NcChannel], and returns it."],["channel_set_rgb8","Sets the three RGB [NcColor]s an [NcChannel], and marks it as not using the \"default color\", retaining the other bits unchanged."],["channels_bchannel","Extracts the background [NcChannel] from a [NcChannelPair]."],["channels_bg_alpha","Gets the background [NcAlphaBits] from an [NcChannelPair], shifted to LSBs."],["channels_bg_default_p","Is the background using the \"default background color\"? The \"default background color\" must generally be used to take advantage of terminal-effected transparency."],["channels_bg_palindex_p","Is the background of an [NcChannelPair] using an [indexed][NcPaletteIndex] [NcPalette][crate::NcPalette] color?"],["channels_bg_rgb","Gets the background [NcRgb] from an [NcChannelPair], shifted to LSBs."],["channels_bg_rgb8","Gets the three background RGB [NcColor]s from an [NcChannelPair], and returns the background [NcChannel] (which can have some extra bits set)."],["channels_combine","Combines two [NcChannel]s into a [NcChannelPair]."],["channels_fchannel","Extracts the foreground [NcChannel] from an [NcChannelPair]."],["channels_fg_alpha","Gets the foreground [NcAlphaBits] from an [NcChannelPair], shifted to LSBs."],["channels_fg_default_p","Is the foreground of an [NcChannelPair] using the \"default foreground color\"?"],["channels_fg_palindex_p","Is the foreground of an [NcChannelPair] using an [indexed][NcPaletteIndex] [NcPalette][crate::NcPalette] color?"],["channels_fg_rgb","Gets the foreground [NcRgb] from an [NcChannelPair], shifted to LSBs."],["channels_fg_rgb8","Gets the three foreground RGB [NcColor]s from an [NcChannelPair], and returns the foreground [NcChannel] (which can have some extra bits set)."],["channels_set_bchannel","Sets the background [NcChannel] of an [NcChannelPair]."],["channels_set_bg_alpha","Sets the [NcAlphaBits] of the background [NcChannel] of an [NcChannelPair]."],["channels_set_bg_default","Marks the background of an [NcChannelPair] as using its \"default color\", and returns the new [NcChannelPair]."],["channels_set_bg_palindex","Sets an [NcCell][crate::NcCell]'s background [NcPaletteIndex]."],["channels_set_bg_rgb","Sets the foreground [NcRgb] of an [NcChannelPair], and marks it as not using the the \"default color\"."],["channels_set_bg_rgb8","Sets the three background RGB [NcColor]s of an [NcChannelPair], and marks it as not using the \"default color\"."],["channels_set_fchannel","Sets the foreground [NcChannel] of an [NcChannelPair]."],["channels_set_fg_alpha","Sets the [NcAlphaBits] of the foreground [NcChannel] of an [NcChannelPair]."],["channels_set_fg_default","Marks the foreground of an [NcChannelPair] as using its \"default color\", and returns the new [NcChannelPair]."],["channels_set_fg_palindex","Sets an [NcCell][crate::NcCell]'s foreground [NcPaletteIndex]."],["channels_set_fg_rgb","Sets the foreground [NcRgb] of an [NcChannelPair], and marks it as not using the the \"default color\"."],["channels_set_fg_rgb8","Sets the three foreground RGB [NcColor]s of an [NcChannelPair], and marks it as not using the \"default color\"."],["ncdirect_bg_default",""],["ncdirect_bg_palindex",""],["ncdirect_bg_rgb",""],["ncdirect_box","Draw a box with its upper-left corner at the current cursor position, having dimensions |ylen|x|xlen|. See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an array of 6 wide characters: UL, UR, LL, LR, HL, VL."],["ncdirect_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["ncdirect_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["ncdirect_clear","Clear the screen."],["ncdirect_cursor_disable",""],["ncdirect_cursor_down",""],["ncdirect_cursor_enable",""],["ncdirect_cursor_left",""],["ncdirect_cursor_move_yx","Move the cursor in direct mode. -1 to retain current location on that axis."],["ncdirect_cursor_pop",""],["ncdirect_cursor_push","Push or pop the cursor location to the terminal's stack. The depth of this stack, and indeed its existence, is terminal-dependent."],["ncdirect_cursor_right",""],["ncdirect_cursor_up",""],["ncdirect_cursor_yx","Get the cursor position, when supported. This requires writing to the terminal, and then reading from it. If the terminal doesn't reply, or doesn't reply in a way we understand, the results might be deleterious."],["ncdirect_dim_x","Get the current number of columns/rows."],["ncdirect_dim_y",""],["ncdirect_double_box","ncdirect_box() with the double box-drawing characters"],["ncdirect_fg_default",""],["ncdirect_fg_palindex",""],["ncdirect_fg_rgb","Direct mode. This API can be used to colorize and stylize output generated outside of notcurses, without ever calling notcurses_render(). These should not be intermixed with standard Notcurses rendering."],["ncdirect_flush","Force a flush. Returns 0 on success, -1 on failure."],["ncdirect_getc","See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking operation, and otherwise a timespec to bound blocking. Signals in sigmask (less several we handle internally) will be atomically masked and unmasked per ppoll(2). '*sigmask' should generally contain all signals. Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the return value is the 'id' field from that event. 'ni' may be NULL."],["ncdirect_hline_interp","Draw horizontal/vertical lines using the specified channels, interpolating between them as we go. The EGC may not use more than one column. For a horizontal line, |len| cannot exceed the screen width minus the cursor's offset. For a vertical line, it may be as long as you'd like; the screen will scroll as necessary. All lines start at the current cursor position."],["ncdirect_init","Initialize a direct-mode Notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually want stdout. Direct mode supports a limited subset of Notcurses routines which directly affect 'fp', and neither supports nor requires notcurses_render(). This can be used to add color and styling to text in the standard output paradigm. 'flags' is a bitmask over NCDIRECT_OPTION_*. Returns NULL on error, including any failure initializing terminfo."],["ncdirect_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call ncdirect_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["ncdirect_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["ncdirect_printf_aligned","Formatted printing (plus alignment relative to the terminal). Returns the number of columns printed on success."],["ncdirect_putstr","Output the string |utf8| according to the channels |channels|. Note that ncdirect_putstr() does not explicitly flush output buffers, so it will not necessarily be immediately visible."],["ncdirect_render_image","Display an image using the specified blitter and scaling. The image may be arbitrarily many rows -- the output will scroll -- but will only occupy the column of the cursor, and those to the right."],["ncdirect_rounded_box","ncdirect_box() with the rounded box-drawing characters"],["ncdirect_stop","Release 'nc' and any associated resources. 0 on success, non-0 on failure."],["ncdirect_styles_off",""],["ncdirect_styles_on",""],["ncdirect_styles_set","ncplane_styles_*() analogues"],["ncdirect_vline_interp",""],["ncdplot_add_sample",""],["ncdplot_create",""],["ncdplot_destroy",""],["ncdplot_plane",""],["ncdplot_sample",""],["ncdplot_set_sample",""],["ncfadectx_free","Release the resources associated with 'nctx'."],["ncfadectx_iterations","Return the number of iterations through which 'nctx' will fade."],["ncfadectx_setup","Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."],["ncfdplane_create","Create an ncfdplane around the fd 'fd'. Consider this function to take ownership of the file descriptor, which will be closed in ncfdplane_destroy()."],["ncfdplane_destroy",""],["ncfdplane_plane",""],["ncinput_equal_p","Compares two ncinput structs for data equality by doing a field-by-field comparison for equality (excepting seqnum)."],["nckey_mouse_p","Is the event a synthesized mouse event?"],["nckey_supppuab_p","Is this u32 a Supplementary Private Use Area-B codepoint?"],["ncmenu_create","Create a menu with the specified options. Menus are currently bound to an overall Notcurses object (as opposed to a particular plane), and are implemented as ncplanes kept atop other ncplanes."],["ncmenu_destroy","Destroy a menu created with ncmenu_create()."],["ncmenu_item_set_status","Disable or enable a menu item. Returns 0 if the item was found."],["ncmenu_mouse_selected","Return the item description corresponding to the mouse click 'click'. The item must be on an actively unrolled section, and the click must be in the area of a valid item. If 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled in with the shortcut."],["ncmenu_nextitem","Move to the previous/next item within the currently unrolled section. If no section is unrolled, the first section will be unrolled."],["ncmenu_nextsection","Unroll the previous/next section (relative to current unrolled). If no section is unrolled, the first section will be unrolled."],["ncmenu_offer_input","Offer the input to the ncmenu. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the menu, false is returned. Relevant inputs include:"],["ncmenu_plane","Return the ncplane backing this ncmenu."],["ncmenu_previtem",""],["ncmenu_prevsection",""],["ncmenu_rollup","Roll up any unrolled menu section, and hide the menu if using hiding."],["ncmenu_selected","Return the selected item description, or NULL if no section is unrolled. If 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled in with that shortcut--this can allow faster matching."],["ncmenu_unroll","Unroll the specified menu section, making the menu visible if it was invisible, and rolling up any menu section that is already unrolled."],["ncmetric","Takes an arbitrarily large number, and prints it into a fixed-size buffer by adding the necessary SI suffix. Usually, pass a |[IB]PREFIXSTRLEN+1|-sized buffer to generate up to |[IB]PREFIXCOLUMNS| columns' worth of EGCs. The characteristic can occupy up through |mult-1| characters (3 for 1000, 4 for 1024). The mantissa can occupy either zero or two characters."],["ncmultiselector_create",""],["ncmultiselector_destroy","Destroy the ncmultiselector."],["ncmultiselector_offer_input","Offer the input to the ncmultiselector. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the multiselector, false is returned. Relevant inputs include:"],["ncmultiselector_plane","Return a reference to the ncmultiselector's underlying ncplane."],["ncmultiselector_selected","Return selected vector. An array of bools must be provided, along with its length. If that length doesn't match the itemcount, it is an error."],["ncpile_bottom","Return the bottommost plane of the pile containing 'n'."],["ncpile_create","Same as ncplane_create(), but creates a new pile. The returned plane will be the top, bottom, and root of this new pile."],["ncpile_rasterize","Make the physical screen match the last rendered frame from the pile of which 'n' is a part. This is a blocking call. Don't call this before the pile has been rendered (doing so will likely result in a blank screen)."],["ncpile_render","Renders the pile of which 'n' is a part. Rendering this pile again will blow away the render. To actually write out the render, call ncpile_rasterize()."],["ncpile_top","Return the topmost plane of the pile containing 'n'."],["ncpixel","Get an RGB pixel from RGB values"],["ncpixel_a","Extract the 8-bit alpha component from a pixel"],["ncpixel_b","Extract the 8 bit blue component from a pixel"],["ncpixel_g","Extract the 8 bit green component from a pixel"],["ncpixel_r","Extract the 8 bit red component from a pixel"],["ncpixel_set_a","Set the 8-bit alpha component of a pixel"],["ncpixel_set_b","Set the 8-bit blue component of a pixel"],["ncpixel_set_g","Set the 8-bit green component of a pixel"],["ncpixel_set_r","Set the 8-bit red component of a pixel"],["ncpixel_set_rgb","set the RGB values of an RGB pixel"],["ncplane_above",""],["ncplane_align","Returns the column at which 'cols' columns ought start in order to be aligned according to 'align' within ncplane 'n'. Returns INT_MAX on invalid 'align'. Undefined behavior on negative 'cols'."],["ncplane_at_cursor","Retrieve the current contents of the cell under the cursor. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["ncplane_at_cursor_cell","Retrieves the current contents of the [NcCell] under the cursor."],["ncplane_at_yx","Retrieve the current contents of the specified cell. The EGC is returned, or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["ncplane_at_yx_cell","Retrieves the current contents of the specified cell into 'cell'. This cell is invalidated if the associated plane is destroyed."],["ncplane_base","Extract the ncplane's base cell into 'c'. The reference is invalidated if 'ncp' is destroyed."],["ncplane_bchannel","Gets the background [NcChannel] from an [NcPlane]."],["ncplane_below","Return the plane below this one, or NULL if this is at the bottom."],["ncplane_bg_alpha","Gets the background [NcAlphaBits] from the [NcPlane], shifted to LSBs."],["ncplane_bg_default_p","Is the plane's background using the \"default background color\"?"],["ncplane_bg_rgb","Gets the background [NcRgb] from an [NcPlane], shifted to LSBs."],["ncplane_bg_rgb8","Gets the background [NcColor] RGB components from an [NcPlane]."],["ncplane_box","Draw a box with its upper-left corner at the current cursor position, and its lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the upper-left, ur, ll, and lr corners, then the horizontal and vertical lines. 'ctlword' is defined in the least significant byte, where bits [7, 4] are a gradient mask, and [3, 0] are a border mask:"],["ncplane_box_sized","Draw a box with its upper-left corner at the current cursor position, having dimensions 'ylen'x'xlen'. See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen."],["ncplane_center_abs",""],["ncplane_channels","Get the current channels or attribute word for ncplane 'n'."],["ncplane_contents","Create a flat string from the EGCs of the selected region of the ncplane 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and 'lenx' can be specified as -1 to go through the boundary of the plane."],["ncplane_create","Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to the origin of 'n') and the specified size. The number of 'rows' and 'cols' must both be positive. This plane is initially at the top of the z-buffer, as if ncplane_move_top() had been called on it. The void* 'userptr' can be retrieved (and reset) later. A 'name' can be set, used in debugging."],["ncplane_cursor_move_yx","Move the cursor to the specified position (the cursor needn't be visible). Returns -1 on error, including negative parameters, or ones exceeding the plane's dimensions."],["ncplane_cursor_yx","Get the current position of the cursor within n. y and/or x may be NULL."],["ncplane_destroy","Destroy the specified ncplane. None of its contents will be visible after the next call to notcurses_render(). It is an error to attempt to destroy the standard plane."],["ncplane_dim_x","Gets the columns of the [NcPlane]."],["ncplane_dim_y","Gets the rows of the [NcPlane]."],["ncplane_dim_yx","Return the dimensions of this ncplane."],["ncplane_double_box",""],["ncplane_double_box_sized",""],["ncplane_dup","Duplicate an existing ncplane. The new plane will have the same geometry, will duplicate all content, and will start with the same rendering state. The new plane will be immediately above the old one on the z axis, and will be bound to the same parent. Bound planes are not duplicated; the new plane is bound to the parent of 'n', but has no bound planes."],["ncplane_erase","Erase every cell in the ncplane (each cell is initialized to the null glyph and the default channels/styles). All cells associated with this ncplane are invalidated, and must not be used after the call, excluding the base cell. The cursor is homed. The plane's active attributes are unaffected."],["ncplane_fadein","Fade the ncplane in over the specified time. Load the ncplane with the target cells without rendering, then call this function. When it's done, the ncplane will have reached the target levels, starting from zeroes."],["ncplane_fadein_iteration","Fade in through 'iter' iterations, where 'iter' < 'ncfadectx_iterations(nctx)'."],["ncplane_fadeout","Fade the ncplane out over the provided time, calling 'fader' at each iteration. Requires a terminal which supports truecolor, or at least palette modification (if the terminal uses a palette, our ability to fade planes is limited, and affected by the complexity of the rest of the screen)."],["ncplane_fadeout_iteration","Fade out through 'iter' iterations, where 'iter' < 'ncfadectx_iterations(nctx)'."],["ncplane_fchannel","Gets the foreground [NcChannel] from an [NcPlane]."],["ncplane_fg_alpha","Gets the foreground [NcAlphaBits] from the [NcPlane], shifted to LSBs."],["ncplane_fg_default_p","Is the plane's foreground using the \"default foreground color\"?"],["ncplane_fg_rgb","Gets the foreground [NcRgb] from an [NcPlane], shifted to LSBs."],["ncplane_fg_rgb8","Gets the foreground [NcColor] RGB components from an [NcPlane]."],["ncplane_format","Set the given style throughout the specified region, keeping content and channels unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_gradient","Draw a gradient with its upper-left corner at the current cursor position, stopping at 'ystop'x'xstop'. The glyph composed of 'egc' and 'stylemask' is used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr' are composed into foreground and background gradients. To do a vertical gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To color everything the same, all four channels should be equivalent. The resulting alpha values are equal to incoming alpha values. Returns the number of cells filled on success, or -1 on failure."],["ncplane_gradient_sized","Draw a gradient with its upper-left corner at the current cursor position, having dimensions 'ylen'x'xlen'. See ncplane_gradient for more information. static inline int"],["ncplane_greyscale","Convert the plane's content to greyscale."],["ncplane_highgradient","Do a high-resolution gradient using upper blocks and synced backgrounds. This doubles the number of vertical gradations, but restricts you to half blocks (appearing to be full blocks). Returns the number of cells filled on success, or -1 on error."],["ncplane_highgradient_sized","ncplane_gradent_sized() meets ncplane_highgradient()."],["ncplane_hline","On error, return the negative number of cells drawn."],["ncplane_hline_interp","Draw horizontal or vertical lines using the specified cell, starting at the current cursor position. The cursor will end at the cell following the last cell output (even, perhaps counter-intuitively, when drawing vertical lines), just as if ncplane_putc() was called at that spot. Return the number of cells drawn on success. On error, return the negative number of cells drawn."],["ncplane_home","Move the cursor to 0, 0. Can't fail."],["ncplane_mergedown","Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously defined as \"write to 'dst' the frame that would be rendered were the entire stack made up only of the specified subregion of 'src' and, below it, the subregion of 'dst' having the specified origin. Merging is independent of the position of 'src' viz 'dst' on the z-axis. It is an error to define a subregion of zero area, or that is not entirely contained within 'src'. It is an error to define a target origin such that the projected subregion is not entirely contained within 'dst'.  Behavior is undefined if 'src' and 'dst' are equivalent. 'dst' is modified, but 'src' remains unchanged."],["ncplane_mergedown_simple","If 'src' does not intersect with 'dst', 'dst' will not be changed, but it is not an error. If 'dst' is NULL, the operation will target the standard plane."],["ncplane_move_above","Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'. Returns non-zero if 'n' is already in the desired location. 'n' and 'above' must not be the same plane."],["ncplane_move_below","Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'. Returns non-zero if 'n' is already in the desired location. 'n' and 'below' must not be the same plane."],["ncplane_move_bottom",""],["ncplane_move_top","Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom."],["ncplane_move_yx","Move this plane relative to the standard plane, or the plane to which it is bound (if it is bound to a plane). It is an error to attempt to move the standard plane."],["ncplane_notcurses","Extract the Notcurses context to which this plane is attached."],["ncplane_notcurses_const",""],["ncplane_off_styles","Remove the specified styles from the ncplane's existing spec."],["ncplane_on_styles","Add the specified styles to the ncplane's existing spec."],["ncplane_parent","Get the plane to which the plane 'n' is bound, if any."],["ncplane_parent_const",""],["ncplane_perimeter",""],["ncplane_perimeter_double",""],["ncplane_perimeter_rounded",""],["ncplane_polyfill_yx","Starting at the specified coordinate, if its glyph is different from that of 'c', 'c' is copied into it, and the original glyph is considered the fill target. We do the same to all cardinally-connected cells having this same fill target. Returns the number of cells polyfilled. An invalid initial y, x is an error. Returns the number of cells filled, or -1 on error."],["ncplane_pulse","Pulse the plane in and out until the callback returns non-zero, relying on the callback 'fader' to initiate rendering. 'ts' defines the half-period (i.e. the transition from black to full brightness, or back again). Proper use involves preparing (but not rendering) an ncplane, then calling ncplane_pulse(), which will fade in from black to the specified colors."],["ncplane_putc","Calls ncplane_putc_yx() for the current cursor location."],["ncplane_putc_yx","Replace the cell at the specified coordinates with the provided cell 'c', and advance the cursor by the width of the cell (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. 'c' must already be associated with 'n'. On failure, -1 is returned."],["ncplane_putchar","Calls ncplane_putchar_yx() at the current cursor location."],["ncplane_putchar_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putchar_yx","Replaces the [NcCell] at the specified coordinates with the provided char. Advances the cursor by 1."],["ncplane_putegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putegc_yx","Replace the cell at the specified coordinates with the provided EGC, and advance the cursor by the width of the cluster (but not past the end of the plane). On success, returns the number of columns the cursor was advanced. On failure, -1 is returned. The number of bytes converted from gclust is written to 'sbytes' if non-NULL."],["ncplane_putnstr",""],["ncplane_putnstr_aligned",""],["ncplane_putnstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error. No more than 's' bytes will be written."],["ncplane_putstr","Writes a series of [NcEgc][crate::NcEgc]s to the current location, using the current style."],["ncplane_putstr_aligned",""],["ncplane_putstr_stained","Replace a string's worth of glyphs at the current cursor location, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putstr_yx","Write a series of EGCs to the current location, using the current style. They will be interpreted as a series of columns (according to the definition of ncplane_putc()). Advances the cursor by some positive number of columns (though not beyond the end of the plane); this number is returned on success. On error, a non-positive number is returned, indicating the number of columns which were written before the error."],["ncplane_puttext","Write the specified text to the plane, breaking lines sensibly, beginning at the specified line. Returns the number of columns written. When breaking a line, the line will be cleared to the end of the plane (the last line will not be so cleared). The number of bytes written from the input is written to '*bytes' if it is not NULL. Cleared columns are included in the return value, but not included in the number of bytes written. Leaves the cursor at the end of output. A partial write will be accomplished as far as it can; determine whether the write completed by inspecting '*bytes'. Can output to multiple rows even in the absence of scrolling, but not more rows than are available. With scrolling enabled, arbitrary amounts of data can be emitted. All provided whitespace is preserved -- ncplane_puttext() followed by an appropriate ncplane_contents() will read back the original output."],["ncplane_putwegc_stained","Replace the EGC underneath us, but retain the styling. The current styling of the plane will not be changed."],["ncplane_putwstr_stained",""],["ncplane_qrcode","Draw a QR code at the current position on the plane. If there is insufficient room to draw the code here, or there is any other error, non-zero will be returned. Otherwise, the QR code \"version\" (size) is returned. The QR code is (version * 4 + 17) columns wide, and ‚åàversion * 4 + 17‚åâ rows tall (the properly-scaled values are written back to '*ymax' and '*xmax')."],["ncplane_reparent","Plane 'n' will be unbound from its parent plane, and will be made a bound child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n' is already the root of a pile, in which case this is a no-op. Returns 'n'. The standard plane cannot be reparented. Any planes bound to 'n' are reparented to the previous parent of 'n'."],["ncplane_reparent_family","The same as ncplane_reparent(), except any planes bound to 'n' come along with it to its new destination. Their z-order is maintained."],["ncplane_resize","Resize the specified ncplane. The four parameters 'keepy', 'keepx', 'keepleny', and 'keeplenx' define a subset of the ncplane to keep, unchanged. This may be a section of size 0, though none of these four parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane. They must specify a coordinate within the ncplane's totality. 'yoff' and 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny', and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx' is non-zero, both must be non-zero."],["ncplane_resize_realign","Suitable for use as a 'resizecb'. This will realign the plane 'n' against its parent, using the alignment specified at ncplane_create()-time."],["ncplane_resize_simple","Resizes the plane, retaining what data we can (everything, unless we're shrinking in some dimension). Keep the origin where it is."],["ncplane_resizecb","Returns the ncplane's current resize callback."],["ncplane_rgba","Create an RGBA flat array from the selected region of the ncplane 'nc'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and 'lenx' can be specified as -1 to go through the boundary of the plane. Only glyphs from the specified blitset may be present."],["ncplane_rotate_ccw",""],["ncplane_rotate_cw","Rotate the plane œÄ/2 radians clockwise or counterclockwise. This cannot be performed on arbitrary planes, because glyphs cannot be arbitrarily rotated. The glyphs which can be rotated are limited: line-drawing characters, spaces, half blocks, and full blocks. The plane must have an even number of columns. Use the ncvisual rotation for a more flexible approach."],["ncplane_rounded_box",""],["ncplane_rounded_box_sized",""],["ncplane_set_base","Set the ncplane's base cell to this cell. It will be used for purposes of rendering anywhere that the ncplane's gcluster is 0. Erasing the ncplane does not reset the base cell; this function must be called with an empty 'egc'. 'egc' must be a single extended grapheme cluster."],["ncplane_set_base_cell","Set the ncplane's base cell to this cell. It will be used for purposes of rendering anywhere that the ncplane's gcluster is 0. Erasing the ncplane does not reset the base cell; this function must be called with a zero 'c'."],["ncplane_set_bchannel",""],["ncplane_set_bg_alpha",""],["ncplane_set_bg_default",""],["ncplane_set_bg_palindex",""],["ncplane_set_bg_rgb",""],["ncplane_set_bg_rgb8",""],["ncplane_set_bg_rgb8_clipped","Same, but clipped to [0..255]."],["ncplane_set_channels",""],["ncplane_set_fchannel","Set an entire 32-bit channel of the plane"],["ncplane_set_fg_alpha","Set the alpha parameters for ncplane 'n'."],["ncplane_set_fg_default","Use the default color for the foreground/background."],["ncplane_set_fg_palindex","Set the ncplane's foreground palette index, set the foreground palette index bit, set it foreground-opaque, and clear the foreground default color bit."],["ncplane_set_fg_rgb","Same, but with rgb assembled into a channel (i.e. lower 24 bits)."],["ncplane_set_fg_rgb8","Set the current fore/background color using RGB specifications. If the terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\", indicated by the \"RGB\" terminfo capability), the provided values will be interpreted in some lossy fashion. None of r, g, or b may exceed 255. \"HP-like\" terminals require setting foreground and background at the same time using \"color pairs\"; Notcurses will manage color pairs transparently."],["ncplane_set_fg_rgb8_clipped",""],["ncplane_set_scrolling","All planes are created with scrolling disabled. Scrolling can be dynamically controlled with ncplane_set_scrolling(). Returns true if scrolling was previously enabled, or false if it was disabled."],["ncplane_set_styles","Set the specified style bits for the ncplane 'n', whether they're actively supported or not."],["ncplane_set_userptr","Manipulate the opaque user pointer associated with this plane. ncplane_set_userptr() returns the previous userptr after replacing it with 'opaque'. the others simply return the userptr."],["ncplane_stain","Set the given channels throughout the specified region, keeping content and attributes unchanged. Returns the number of cells set, or -1 on failure."],["ncplane_styles","Return the current styling for this ncplane."],["ncplane_styles_off",""],["ncplane_styles_on",""],["ncplane_styles_set","Deprecated forms of above."],["ncplane_translate","provided a coordinate relative to the origin of 'src', map it to the same absolute coordinate relative to thte origin of 'dst'. either or both of 'y' and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."],["ncplane_translate_abs","Fed absolute 'y'/'x' coordinates, determine whether that coordinate is within the ncplane 'n'. If not, return false. If so, return true. Either way, translate the absolute coordinates relative to 'n'. If the point is not within 'n', these coordinates will not be within the dimensions of the plane."],["ncplane_userptr",""],["ncplane_vline","On error, return the negative number of cells drawn."],["ncplane_vline_interp",""],["ncplane_vprintf","The [NcPlane] equivalent of `vprintf(3)`."],["ncplane_vprintf_aligned","The ncplane equivalents of printf(3) and vprintf(3)."],["ncplane_vprintf_stained",""],["ncplane_vprintf_yx",""],["ncplane_x",""],["ncplane_y",""],["ncplane_yx","Get the origin of this plane relative to the standard plane, or the plane to which it is bound (if it is bound to a plane)."],["ncreader_clear","empty the ncreader of any user input, and home the cursor."],["ncreader_contents","return a heap-allocated copy of the current (UTF-8) contents."],["ncreader_create","ncreaders provide freeform input in a (possibly multiline) region, supporting optional readline keybindings. takes ownership of 'n', destroying it on any error (ncreader_destroy() otherwise destroys the ncplane)."],["ncreader_destroy","destroy the reader and its bound plane. if 'contents' is not NULL, the UTF-8 input will be heap-duplicated and written to 'contents'."],["ncreader_move_down",""],["ncreader_move_left","Atttempt to move in the specified direction. Returns 0 if a move was successfully executed, -1 otherwise. Scrolling is taken into account."],["ncreader_move_right",""],["ncreader_move_up",""],["ncreader_offer_input","Offer the input to the ncreader. If it's relevant, this function returns true, and the input ought not be processed further. Almost all inputs are relevant to an ncreader, save synthesized ones."],["ncreader_plane",""],["ncreader_write_egc","Destructively write the provided EGC to the current cursor location. Move the cursor as necessary, scrolling if applicable."],["ncreel_add","Add a new nctablet to the provided ncreel 'nr', having the callback object 'opaque'. Neither, either, or both of 'after' and 'before' may be specified. If neither is specified, the new tablet can be added anywhere on the reel. If one or the other is specified, the tablet will be added before or after the specified tablet. If both are specified, the tablet will be added to the resulting location, assuming it is valid (after->next == before->prev); if it is not valid, or there is any other error, NULL will be returned."],["ncreel_create","Take over the ncplane 'nc' and use it to draw a reel according to 'popts'. The plane will be destroyed by ncreel_destroy(); this transfers ownership."],["ncreel_del","Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the tablet cannot be found."],["ncreel_destroy","Destroy an ncreel allocated with ncreel_create()."],["ncreel_focused","Return the focused tablet, if any tablets are present. This is not a copy; be careful to use it only for the duration of a critical section."],["ncreel_next","Change focus to the next tablet, if one exists"],["ncreel_offer_input","Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the reel, false is returned. Relevant inputs include:"],["ncreel_plane","Returns the ncplane on which this ncreel lives."],["ncreel_prev","Change focus to the previous tablet, if one exists"],["ncreel_redraw","Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and tablets will be lain out, using the focused tablet as a fulcrum. Tablet drawing callbacks will be invoked for each visible tablet."],["ncreel_tabletcount","Return the number of nctablets in the ncreel 'nr'."],["ncselector_additem","Dynamically add or delete items. It is usually sufficient to supply a static list of items via ncselector_options->items."],["ncselector_create",""],["ncselector_delitem",""],["ncselector_destroy","Destroy the ncselector. If 'item' is not NULL, the last selected option will be strdup()ed and assigned to '*item' (and must be free()d by the caller)."],["ncselector_nextitem",""],["ncselector_offer_input","Offer the input to the ncselector. If it's relevant, this function returns true, and the input ought not be processed further. If it's irrelevant to the selector, false is returned. Relevant inputs include:"],["ncselector_plane","Return a reference to the ncselector's underlying ncplane."],["ncselector_previtem","Move up or down in the list. A reference to the newly-selected item is returned, or NULL if there are no items in the list."],["ncselector_selected","Return reference to the selected option, or NULL if there are no items."],["ncstrwidth","Returns the number of columns occupied by a multibyte (UTF-8) string, or -1 if a non-printable/illegal character is encountered."],["nctablet_plane","Access the ncplane associated with nctablet 't', if one exists."],["nctablet_userptr","Returns a pointer to a user pointer associated with this nctablet."],["ncuplot_add_sample","Add to or set the value corresponding to this x. If x is beyond the current x window, the x window is advanced to include x, and values passing beyond the window are lost. The first call will place the initial window. The plot will be redrawn, but notcurses_render() is not called."],["ncuplot_create","Use the provided plane 'n' for plotting according to the options 'opts'. The plot will make free use of the entirety of the plane. For domain autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while ncdplot holds doubles."],["ncuplot_destroy",""],["ncuplot_plane","Return a reference to the ncplot's underlying ncplane."],["ncuplot_sample",""],["ncuplot_set_sample",""],["ncvisual_at_yx","Get the specified pixel from the specified ncvisual."],["ncvisual_decode","extract the next frame from an ncvisual. returns 1 on end of file, 0 on success, and -1 on failure."],["ncvisual_decode_loop","decode the next frame ala ncvisual_decode(), but if we have reached the end, rewind to the first frame of the ncvisual. a subsequent 'ncvisual_render()' will render the first frame, as if the ncvisual had been closed and reopened. the return values remain the same as those of ncvisual_decode()."],["ncvisual_default_blitter","Returns the best default blitter available"],["ncvisual_destroy","Destroy an ncvisual. Rendered elements will not be disrupted, but the visual can be neither decoded nor rendered any further."],["ncvisual_from_bgra","ncvisual_from_rgba(), but 'bgra' is arranged as BGRA."],["ncvisual_from_file","Open a visual at 'file', extract a codec and parameters, decode the first image to memory."],["ncvisual_from_plane","Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces, half blocks, and full blocks. The latter will be checked, and any other glyph will result in a NULL being returned. This function exists so that planes can be subjected to ncvisual transformations. If possible, it's better to create the ncvisual from memory using ncvisual_from_rgba()."],["ncvisual_from_rgba","Prepare an ncvisual, and its underlying plane, based off RGBA content in memory at 'rgba'. 'rgba' must be a flat array of 32-bit 8bpc RGBA pixels. These must be arranged in 'rowstride' lines, where the first 'cols' * 4b are actual data. There must be 'rows' lines. The total size of 'rgba' must thus be at least (rows * rowstride) bytes, of which (rows * cols * 4) bytes are actual data. Resulting planes are ceil('rows' / 2) x 'cols'."],["ncvisual_geom","Get the size and ratio of ncvisual pixels to output cells along the y ('toy') and x ('tox') axes. A ncvisual of '*y'X'*x' pixels will require ('*y' * '*toy')X('x' * 'tox') cells for full output. Returns non-zero for an invalid 'vopts->blitter'. Scaling is taken into consideration."],["ncvisual_polyfill_yx","Polyfill at the specified location within the ncvisual 'n', using 'rgba'."],["ncvisual_render","Render the decoded frame to the specified ncplane (if one is not provided, one will be created, having the exact size necessary to display the visual. In this case, 'style' must be NCSTYLE_NONE). A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and 'leny'. Negative values for 'begy' or 'begx' are an error. It is an error to specify any region beyond the boundaries of the frame. Returns the plane to which we drew (if ncv->n is NULL, a new plane will be created)."],["ncvisual_resize","Resize the visual so that it is 'rows' X 'columns'. This is a lossy transformation, unless the size is unchanged."],["ncvisual_rotate","Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are supported at the moment, but this will change FIXME."],["ncvisual_set_yx","Set the specified pixel in the specified ncvisual."],["ncvisual_simple_streamer","Shut up and display my frames! Provide as an argument to ncvisual_stream(). If you'd like subtitles to be decoded, provide an ncplane as the curry. If the curry is NULL, subtitles will not be displayed."],["ncvisual_stream","Stream the entirety of the media, according to its own timing. Blocking, obviously. streamer may be NULL; it is otherwise called for each frame, and its return value handled as outlined for streamcb. If streamer() returns non-zero, the stream is aborted, and that value is returned. By convention, return a positive number to indicate intentional abort from within streamer(). 'timescale' allows the frame duration time to be scaled. For a visual naturally running at 30FPS, a 'timescale' of 0.1 will result in 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to supply 'timescale' less than or equal to 0."],["ncvisual_subtitle","If a subtitle ought be displayed at this time, return a heap-allocated copy of the UTF8 text."],["notcurses_align","return the offset into 'availcols' at which 'cols' ought be output given the requirements of 'align'"],["notcurses_at_yx","Retrieve the contents of the specified cell as last rendered. Returns the EGC or NULL on error. This EGC must be free()d by the caller. The stylemask and channels are written to 'stylemask' and 'channels', respectively."],["notcurses_bottom","Return the bottommost ncplane, of which there is always at least one."],["notcurses_canchangecolor","Can we set the \"hardware\" palette? Requires the \"ccc\" terminfo capability."],["notcurses_canfade","Can we fade? Fading requires either the \"rgb\" or \"ccc\" terminfo capability."],["notcurses_canopen_images","Can we load images? This requires being built against FFmpeg/OIIO."],["notcurses_canopen_videos","Can we load videos? This requires being built against FFmpeg."],["notcurses_cansixel","Can we blit to Sixel?"],["notcurses_cantruecolor","Can we directly specify RGB values per cell, or only use palettes?"],["notcurses_canutf8","Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."],["notcurses_cursor_disable",""],["notcurses_cursor_enable","Enable or disable the terminal's cursor, if supported, placing it at 'y', 'x'. Immediate effect (no need for a call to notcurses_render()). It is an error if 'y', 'x' lies outside the standard plane."],["notcurses_debug","Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform, and subject to change. It includes geometry of all planes."],["notcurses_drop_planes","Destroy all ncplanes other than the stdplane."],["notcurses_getc","See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking operation, and otherwise a timespec to bound blocking. Signals in sigmask (less several we handle internally) will be atomically masked and unmasked per ppoll(2). It should generally contain all signals. Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the return value is the 'id' field from that event. 'ni' may be NULL."],["notcurses_getc_nblock","'input' may be NULL if the caller is uninterested in event details. If no event is ready, returns 0."],["notcurses_getc_nblocking","'input' may be NULL if the caller is uninterested in event details. Blocks until an event is processed or a signal is received."],["notcurses_init","Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in which case /dev/tty will be opened. Returns NULL on error, including any failure initializing terminfo."],["notcurses_inputready_fd","Get a file descriptor suitable for input event poll()ing. When this descriptor becomes available, you can call notcurses_getc_nblock(), and input ought be ready. This file descriptor is not necessarily the file descriptor associated with stdin (but it might be!)."],["notcurses_lex_blitter","Lex a blitter."],["notcurses_lex_margins","Lex a margin argument according to the standard Notcurses definition. There can be either a single number, which will define all margins equally, or there can be four numbers separated by commas."],["notcurses_lex_scalemode","Lex a visual scaling mode (one of \"none\", \"stretch\", or \"scale\")."],["notcurses_mouse_disable","Disable mouse events. Any events in the input queue can still be delivered."],["notcurses_mouse_enable","Enable the mouse in \"button-event tracking\" mode with focus detection and UTF8-style extended coordinates. On failure, -1 is returned. On success, 0 is returned, and mouse events will be published to notcurses_getc()."],["notcurses_palette_size","Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support. Note that several terminal emulators advertise more colors than they actually support, downsampling internally."],["notcurses_refresh","Refresh the physical screen to match what was last rendered (i.e., without reflecting any changes since the last call to notcurses_render()). This is primarily useful if the screen is externally corrupted, or if an NCKEY_RESIZE event has been read and you're not yet ready to render."],["notcurses_render","Renders and rasterizes the standard pile in one shot. Blocking call."],["notcurses_render_to_buffer","Perform the rendering and rasterization portion of notcurses_render(), but do not write the resulting buffer out to the terminal. Using this function, the user can control the writeout process, and render a second frame while writing another. The returned buffer must be freed by the caller."],["notcurses_render_to_file","Write the last rendered frame, in its entirety, to 'fp'. If notcurses_render() has not yet been called, nothing will be written."],["notcurses_stats","Acquire an atomic snapshot of the Notcurses object's stats."],["notcurses_stats_alloc","Allocate an ncstats object. Use this rather than allocating your own, since future versions of Notcurses might enlarge this structure."],["notcurses_stats_reset","Reset all cumulative stats (immediate ones, such as fbbytes, are not reset)."],["notcurses_stddim_yx","notcurses_stdplane(), plus free bonus dimensions written to non-NULL y/x!"],["notcurses_stddim_yx_const","notcurses_stdplane_const(), plus free bonus dimensions written to non-NULL y/x!"],["notcurses_stdplane","Get a reference to the standard plane (one matching our current idea of the terminal size) for this terminal. The standard plane always exists, and its origin is always at the uppermost, leftmost cell of the terminal."],["notcurses_stdplane_const",""],["notcurses_stop","Destroy a Notcurses context."],["notcurses_str_blitter","Get the name of a blitter."],["notcurses_str_scalemode","Get the name of a scaling mode."],["notcurses_supported_styles","Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only indicated as supported if the terminal can support it together with color. For more information, see the \"ncv\" capability in terminfo(5)."],["notcurses_term_dim_yx","Return our current idea of the terminal dimensions in rows and cols."],["notcurses_top","Return the topmost ncplane, of which there is always at least one."],["notcurses_ucs32_to_utf8","input functions like notcurses_getc() return ucs32-encoded char32_t. convert a series of char32_t to utf8. result must be at least 4 bytes per input char32_t (6 bytes per char32_t will future-proof against Unicode expansion). the number of bytes used is returned, or -1 if passed illegal ucs32, or too small of a buffer."],["notcurses_version","Get a human-readable string describing the running Notcurses version."],["notcurses_version_components","Cannot be inline, as we want to get the versions of the actual Notcurses library we loaded, not what we compile against."],["palette256_free","Free the palette store 'p'."],["palette256_get_rgb","Extract the three 8-bit R/G/B components from an entry inside a palette store."],["palette256_new","Create a new palette store. It will be initialized with notcurses' best knowledge of the currently configured palette. The palette upon startup cannot be reliably detected, sadly."],["palette256_set","Same as `palette256_set_rgb()` but set an assembled 24 bit channel at once."],["palette256_set_rgb","Set the different color components of an entry inside a palette store."],["palette256_use","Attempt to configure the terminal with the provided palette 'p'. Does not transfer ownership of 'p'; palette256_free() can (ought) still be called."],["sigaddset","Add SIGNO to SET."],["sigdelset","Remove SIGNO from SET."],["sigemptyset","Clear all signals from SET."],["sigfillset","Set all signals in SET."],["sigismember","Return 1 if SIGNO is in SET, 0 if not."],["sigpending","Put in SET all signals that are blocked and waiting to be delivered."],["sigprocmask","Get and/or change the set of blocked signals."],["sigsuspend","Change the set of blocked signals to SET, wait until a signal arrives, and restore the set of blocked signals."]],"macro":[["cstring","Converts `&str` to `*mut CString`, for when `*const c_char` is needed."],["rsleep","Renders the [Notcurses][crate::Notcurses] object sleeps for $ms milliseconds."],["sleep","Sleeps for $ms milliseconds."]],"mod":[["ffi","Rust FFI bindings, automatically generated with bindgen."]],"static":[["APPEND_ONLY","Intended to be passed into the CFile::open method. It will only allow data to be appended to the end of the file."],["APPEND_READ","Intended to be passed into the CFile::open method. It will allow data to be appended to the end of the file, and data to be read from the file. It will create the file if it doesn't exist."],["RANDOM_ACCESS_MODE","Intended to be passed into the CFile::open method. It will open the file in a way that will allow reading and writing, including overwriting old data. It will not create the file if it does not exist."],["READ_ONLY","Intended to be passed into the CFile::open method. It will only allow reading."],["TRUNCATE_RANDOM_ACCESS_MODE","Intended to be passed into the CFile::open method. It will open the file in a way that will allow reading and writing, including overwriting old data. It will create the file if it doesn't exist"],["UPDATE","Intended to be passed into the CFile::open method. It will open the file in a way that will allow reading and writing, including overwriting old data"],["WRITE_ONLY","Intended to be passed into the CFile::open method. It will only allow writing."]],"struct":[["NcFile","A wrapper struct around `libc::FILE`"],["__va_list_tag",""]],"trait":[["NcChannelMethods","Enables the methods of [NcChannel];"],["NcChannelPairMethods","Enables the methods of [NcChannelPair];"]],"type":[["FILE_LIBC","See [NcFile]. The [`libc`] crate expects this type of `*FILE` (an opaque enum)"],["FILE_NC","See [NcFile]. Notcurses functions expects this type of `*FILE` (a struct)"],["NcAlign","Alignment within a plane or terminal. Left/right-justified, or centered."],["NcAlphaBits","2 bits of alpha (surrounded by context dependent bits). It is part of an [`NcChannel`]."],["NcBlitSet","the [NcEgc][crate::NcEgc] which form the various levels of a given geometry."],["NcBlitter","Blitter Mode (`NCBLIT_*`)"],["NcCell","A coordinate on an [`NcPlane`][crate::NcPlane] storing 128 bits of data"],["NcChannel","32 bits of context-dependent info containing RGB + 2 bits of alpha + extra"],["NcChannelPair","64 bits containing a foreground and background [`NcChannel`]"],["NcColor","8 bits representing a R/G/B color or alpha channel"],["NcDirect","Minimal notcurses instances for styling text"],["NcDirectFlags","Flags (options) for [`NcDirect`]"],["NcEgc","Extended Grapheme Cluster. A 32-bit [`char`]-like type"],["NcEgcBackstop","An `u8` always at zero, part of the [`NcCell`] struct"],["NcFadeCtx","Context for a palette fade operation"],["NcFdPlane","I/O wrapper to dump file descriptor to [`NcPlane`]"],["NcFdPlaneOptions","Options struct for [`NcFdPlane`]"],["NcInput","Reads and decodes input events"],["NcLogLevel","Log level for [`NotcursesOptions`]"],["NcMenu","menus on the top or bottom rows"],["NcMenuItem","Item for [`NcMenu`]"],["NcMenuOptions","Options struct for [`NcMenu`]"],["NcMenuSection","Section for [`NcMenu`]"],["NcMultiSelector","high-level widget for selecting items from a set"],["NcMultiSelectorItem","an item for [`NcMultiSelector`]"],["NcMultiSelectorOptions","Options structure for [`NcMultiSelector`]"],["NcPalette","NcPalette structure consisting of an array of 256 [`NcChannel`][crate::NcChannel]s."],["NcPaletteIndex","8-bit value used for indexing into a [`NcPalette`]"],["NcPixel","32 bits broken into RGB + 8-bit alpha"],["NcPlane","Fundamental drawing surface."],["NcPlaneOptions","Options struct for [`NcPlane`]"],["NcPlotF64","A histogram, bound to an [`NcPlane`][crate::NcPlane] (uses non-negative `f64`s)"],["NcPlotOptions","Options struct for [`NcPlotF64`] or [`NcPlotU64`]"],["NcPlotU64","A histogram, bound to an [`NcPlane`][crate::NcPlane] (uses `u64`s)"],["NcReader","Provides a freeform input in a (possibly multiline) region"],["NcReaderOptions","Options struct for [`NcReader`]"],["NcReel","A wheel with `NcTablet`s on the outside"],["NcReelOptions","Options struct for [`NcReel`]"],["NcResult","`i32` value used to return errors, when value < 0, (usually -1). See also [`NCRESULT_OK`] and [`NCRESULT_ERR`]."],["NcRgb","24 bits broken into 3x 8bpp channels."],["NcScale","How to scale an [`NcVisual`] during rendering"],["NcSelector","high-level widget for selecting one item from a set"],["NcSelectorItem","an item for [`NcSelector`]"],["NcSelectorOptions","Options structur for [`NcSelector`]"],["NcStats","notcurses runtime statistics"],["NcStyleMask","An `u16` of `NCSTYLE_*` boolean styling attribute flags"],["NcTablet","Visual tablet for [`NcReel`]"],["NcTime",""],["NcVisual","A visual bit of multimedia opened with LibAV|OIIO"],["NcVisualOptions","Options struct for [`NcVisual`]"],["Notcurses","The main struct of the (full mode) TUI library"],["NotcursesOptions","Options struct for [`Notcurses`]"]]});